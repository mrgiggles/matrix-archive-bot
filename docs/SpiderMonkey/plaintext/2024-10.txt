2024-10-01
[03:26:11.0343] <smaug>
Who might have some opinion on https://github.com/whatwg/html/issues/10617 ?

[05:12:32.0630] <jonco>
smaug: hey, I looked at the JS proposal for that but came away a bit confused as to what this is for. The proposal itself mainly talks about improving static analysis and being necessary for for other later proposals, but those proposals don't reference this one or seem to require it. 


2024-10-02
[18:37:35.0999] <zihco>
Hi everyone. I am Chizoba, an Outreachy internship applicant. And I am interested in contributing to SpiderMonkey

[21:15:55.0350] <zihco>
On [Outreachy] Update test262 and test262 skipped files, the jstests.list is up to date. I had follow through the steps, and all the jstests had passed. The task requires I make a commit with the bug's number, but there appears to be no bug currently. Do I make the commit still without a bug number or i missed out something

[22:05:16.0906] <nchevobbe>
if there is no bug, you can create one https://bugzilla.mozilla.org/enter_bug.cgi?product=Core&component=JavaScript%20Engine

[01:57:26.0941] <mayankleoboy1>
Hi Jan! Is it worth filing bugs to track the regressions on [wasm-misc-optimizing-fannkuch](https://bugzilla.mozilla.org/show_bug.cgi?id=1918970#c13) and [Jetstream2-float-mm.c-Average](https://bugzilla.mozilla.org/show_bug.cgi?id=1920951#c7) ?  I dont know if these tests are that important...

[02:20:11.0557] <zihco>
I mean all of the test passed. The task require I update jstests.list to skip failing tests, but none failed. 

[02:21:01.0516] <syedbarimanjan>
Hi have done that too and written a comment on the bug that there is nothing wrong with the tests.

[02:21:16.0531] <syedbarimanjan>
and you should leave a comment on the bug if you are working on it.

[02:22:18.0731] <zihco>
 * I mean all of the tests passed. The task requires I update jstests.list to skip failing tests after updating test262, but none failed. 

[02:22:57.0727] <zihco>
okay

[02:33:07.0952] <jandem>
mayankleoboy1: is the float-mm one Mac only? it's an asm.js test and if it just returned to the baseline after an earlier improvement I don't think we should worry about it

[02:38:56.0891] <jandem>
I needinfod myself to look at the fannkuch one

[06:36:07.0069] <zihco>
 * \[Outreachy\] Update test262 and test262 skipped files, the jstests.list is up to date. I had follow through the steps, and all the jstests had passed. The task requires I make a commit with the bug's number, but there appears to be no bug currently. Do I make the commit still without a bug number or i missed out something

[07:13:50.0277] <sefeng>
hey folks, I want to set a variable at https://searchfox.org/mozilla-central/rev/3966e5534ddf922b186af4777051d579fd052bad/dom/webscheduling/WebTaskScheduler.cpp#105, so that it's set before the callback is run, but I also want to unset it when the callback is done. 

[07:14:10.0836] <sefeng>
I am not sure how to do it when the callback is an async function

[07:14:58.0840] <sefeng>
I mean the callback could have `await ...`, I'd like to unset it when all of that is finished

[07:30:49.0303] <arai>
doing an equivalent of `returnVal.finally(() => unset())` would do that if the `returnVal` is definitely a Promise, or `Promise.resolve(returnVal).finally(...)` if `returnVal` can also be something else.   but if the callback is user-provided code and it can return random thing, it's hard to guarantee things work safely

[07:39:20.0540] <sefeng>
arai: hmm, it's user-provided code. We don't have a way to track the...continuation? 

[07:41:26.0938] <arai>
what's the requirement on the API, or what's the restriction on the task code?  how is "continuation" be defined?

[07:43:07.0273] <sefeng>
arai: I am trying to implement 11.2.2 and 11.2.4 in https://wicg.github.io/scheduling-apis/#schedule-a-posttask-task

[07:44:34.0270] <arai>
so, the callback is `any ()`

[07:45:33.0578] <arai>
when should the unset operation be done?

[07:46:14.0552] <arai>
for example, what should happen if the callback returns a promise that never resolves?

[07:47:36.0339] <syedbarimanjan>
Hey i wanted to ask how do i check when the file was last changed, looking for something like gitlens where it shows on everyline who changed the line last and the pr number.

[07:48:31.0192] <Aditi>
You can use: https://searchfox.org/ 

[07:49:20.0602] <syedbarimanjan>
> <@asingh:igalia.com> You can use: https://searchfox.org/

Thanks but i wanted to know if there is a way to do it in the ide itself.

[07:49:32.0207] <arai>
if you've already cloned the repository, you can use `hg annotate PATH` or `git blame PATH`

[07:49:57.0818] <syedbarimanjan>
> <@arai:mozilla.org> if you've already cloned the repository, you can use `hg annotate PATH` or `git blame PATH`

Will try it.

[07:50:03.0235] <arai>
the way to achieve it on IDE would totally depend on the IDE you're using

[07:50:34.0900] <syedbarimanjan>
> <@arai:mozilla.org> the way to achieve it on IDE would totally depend on the IDE you're using

I am comfortable with alot of ide's.

[07:52:21.0075] <syedbarimanjan>
> <@arai:mozilla.org> the way to achieve it on IDE would totally depend on the IDE you're using

 * I am comfortable with alot of IDE's.

[07:53:49.0587] <sefeng>
not sure, but I interpret it as it can be left there and never unset it  

[07:54:03.0703] <sefeng>
though the next postTask could unset it

[07:54:30.0957] <arai>
just to make sure, is the variable part of the spec?  if so, which one?

[07:55:59.0903] <sefeng>
the `state` thingy, `Set event loop‚Äôs current scheduling state to state.` 

[07:56:14.0470] <arai>
oh, okay

[07:57:05.0118] <arai>
so, according to the spec, you don't have to wait for async function or any promise. there's nothing that waits for it in the step 3

[07:57:33.0129] <arai>
only the synchronous part of the callback will be executed with the "current scheduling state" being the "state"

[07:58:05.0887] <sefeng>
right..I was about to ask. I think it's wrong, at least the test cases don't expect that. 

[07:58:46.0409] <sefeng>
for example https://searchfox.org/mozilla-central/rev/3966e5534ddf922b186af4777051d579fd052bad/testing/web-platform/tests/scheduler/tentative/yield/yield-priority-posttask.any.js#16 expects all `scheduler.yield()` uses the same priority, which means same `state` in this case

[08:00:13.0152] <arai>
in that case the spec needs to be rewritten to wait on the `result` promise

[08:00:42.0193] <sefeng>
yeah I'll file a spec issue about..but still I need a way to wait for the entire function to be resolved 

[08:01:27.0612] <sefeng>
maybe I can just check if the callback is a promise, and do the promise.finally approach?

[08:01:47.0720] <arai>
you don't have to think about how the callback function is written.  the "result" promise is resolved with the callback's result

[08:02:16.0955] <arai>
so, the unset operation should be performed as `result.finally(() => unset())`

[08:03:38.0089] <sefeng>
result is `mPromise` in the code?

[08:03:51.0874] <arai>
yes

[08:04:44.0313] <arai>
so, `mPromise->ThenCatchSOMETHING(...)` maybe?

[08:12:45.0677] <sefeng>
will give it a try, thanks! 

[10:49:42.0596] <sefeng>
arai: I asked this in the spec https://github.com/WICG/scheduling-apis/issues/111#issuecomment-2389245559, I think I get what Scott is saying. Basically the scheduler spec modifies `HostMakeJobCallback` so that the "state" thing is persist across the call. Do you think this makes sense? 

[10:49:54.0045] <sefeng>
 * arai: I asked this in the spec https://github.com/WICG/scheduling-apis/issues/111#issuecomment-2389245559, I think I get what Scott is saying. Basically the scheduler spec modifies `HostMakeJobCallback` so that the "state" thing persists across the call. Do you think this makes sense?

[10:59:08.0536] <arai>
yeah, in that case , you can synchronously unset the variable at step 4.

[11:03:12.0346] <sefeng>
hmm, do you mean I could unset at https://searchfox.org/mozilla-central/source/dom/webscheduling/WebTaskScheduler.cpp#109 ? 

[11:06:02.0583] <arai>
yes

[11:07:03.0771] <arai>
err, in order to exactly follow the spec, put it after maybeResolve below

[11:07:46.0665] <arai>
resolving promise there can also create a job

[11:08:32.0439] <sefeng>
hmm, I feel that's probably not what the spec author wants. 

Say I have this script
```
    scheduler.postTask(async function() {
      for (var i = 0; i< 4; i++) {
        await scheduler.yield();
      }
    });

```
If I unset it synchronously, calling `await scheduler.yield()` the second time won't have the same "state", right?

[11:09:31.0928] <arai>
that part should be covered by the state restored by the HostRunCallbackJob

[11:10:14.0254] <arai>
err, maybe it doesn't work well

[11:10:40.0901] <arai>
the job isn't guaranteed to be created synchronously 

[11:11:23.0393] <arai>
unless the state is carried with pending reactions

[11:11:56.0734] <arai>
I'll read the spec some more

[11:15:51.0611] <sefeng>
yeah, I think Chrome implements something like that https://chromium-review.googlesource.com/c/v8/v8/+/5006444 

[11:16:27.0670] <sefeng>
sounds like something that can carry the state..

[11:19:11.0954] <arai>
oh, wait.  I'm misunderstanding what `HostMakeJobCallback` is

[11:19:26.0069] <arai>
it's called in https://tc39.es/ecma262/#sec-performpromisethen

[11:20:02.0448] <arai>
which is part of `await`'s synchronous part

[11:20:23.0572] <arai>
so, indeed the state is carried with pending reaction

[11:20:58.0644] <arai>
(at least in term of the spec)

[11:21:58.0370] <arai>
but we don't do that, or even, we don't have `HostMakeJobCallback` afaik

[11:22:08.0671] <arai>
so, that part needs to be implemented in SpiderMonkey

[11:23:35.0828] <sefeng>
okay, cool...at least I can close the spec issue :) 

[11:23:51.0867] <arai>
what we have is [JS::JobQueue::getIncumbentGlobal](https://searchfox.org/mozilla-central/rev/3966e5534ddf922b186af4777051d579fd052bad/js/public/Promise.h#45), which is the step 1 in https://html.spec.whatwg.org/multipage/webappapis.html#hostmakejobcallback

[11:37:55.0931] <sefeng>
the original `result->Then(...)` approach wouldn't work? 

[11:57:14.0851] <arai>
yeah, that doesn't match the spec , especially when there are two tasks with different state value running

[12:13:11.0827] <sefeng>
arai: thanks! I am happy to implement that, but I think I need more pointers....

[12:15:48.0344] <arai>
great! feel free to ping me

[14:44:55.0066] <sefeng>
arai: so er..just to confirm my understanding. Should I make a callback that passes those as arguments, and then add this callback to the promise resolve chain?

[15:25:37.0327] <mccr8>
What are "fuses" such as RealmFuses?

[15:35:02.0670] <sfink>
I don't know the details, they're mgaudet's thing, but the basic idea is that they're conditions that JIT generated code depends on, such that if the condition changes the code will be thrown out. https://searchfox.org/mozilla-central/rev/7e0ae4372c52b8183d1178132dd6493edb576738/js/src/vm/GuardFuse.h#21-59 seems to be the SMDOC (which I will now read and see if I got it right)

[15:36:20.0150] <sfink>
looks like I was talking about the 2nd model; they can also be used in regular C++ code to choose a path


2024-10-03
[17:22:56.0158] <arai>
Things need to be done would be:
  * (1) Perform the additional [HostMakeJobCallback](https://wicg.github.io/scheduling-apis/#sec-patches-html-hostmakejobcallback) steps
  * (1.1) Modify [JS::JobQueue](https://searchfox.org/mozilla-central/rev/7e0ae4372c52b8183d1178132dd6493edb576738/js/public/Promise.h#34) to make it possible to pass the current `[[SchedulingState]]` value from the embedding to SpiderMonkey, as a part of `[[HostDefined]]`
  * (1.1) Call the new JS::JobQueue method when creating a reaction in [NewReactionRecord](https://searchfox.org/mozilla-central/rev/7e0ae4372c52b8183d1178132dd6493edb576738/js/src/builtin/Promise.cpp#5146-5151,5164,5186-5187) (which corresponds to HostMakeJobCallback done in [PerformPromiseThen](https://tc39.es/ecma262/#sec-performpromisethen)) and associate it to the reaction
  * (2) Pass the additional `[[HostDefined]]` value to the embedding back when enqueueing the job
  * (2.1) Modify [JS::JobQueue::enqueuePromiseJob](https://searchfox.org/mozilla-central/rev/7e0ae4372c52b8183d1178132dd6493edb576738/js/public/Promise.h#56) to make it possible to pass the `[[SchedulingState]]` value (separate parameter, or maybe wrap incumbentGlobal and SchedulingState into single parameter to allow future extension)
  * (2.2) Modify the Gecko's side to store the `[[SchedulingState]]` value to the promise job (somewhere around [mozilla::CycleCollectedJSContext::enqueuePromiseJob](https://searchfox.org/mozilla-central/rev/7e0ae4372c52b8183d1178132dd6493edb576738/xpcom/base/CycleCollectedJSContext.cpp#250-251))
  * (3) Perform the additional [HostCallJobCallback](https://wicg.github.io/scheduling-apis/#sec-patches-html-hostcalljobcallback) steps
  * (3.1) Currently the incumbentGlobal handling is done before by [CallSetup](https://searchfox.org/mozilla-central/rev/7e0ae4372c52b8183d1178132dd6493edb576738/dom/bindings/CallbackObject.cpp#274,287) before calling the job, but in order to exactly follow the spec, the handling should be done as part of HostCallJobCallback, which is performed [inside the job](https://tc39.es/ecma262/#sec-newpromisereactionjob), only when the handler is not EMPTY.  So either modify the ordering, or somehow make it possible to perform the equivalent with the current CallSetup way


[17:23:17.0857] <arai>
 * Things need to be done would be:
  * (1) Perform the additional [HostMakeJobCallback](https://wicg.github.io/scheduling-apis/#sec-patches-html-hostmakejobcallback) steps
  * (1.1) Modify [JS::JobQueue](https://searchfox.org/mozilla-central/rev/7e0ae4372c52b8183d1178132dd6493edb576738/js/public/Promise.h#34) to make it possible to pass the current `[[SchedulingState]]` value from the embedding to SpiderMonkey, as a part of `[[HostDefined]]`
  * (1.2) Call the new JS::JobQueue method when creating a reaction in [NewReactionRecord](https://searchfox.org/mozilla-central/rev/7e0ae4372c52b8183d1178132dd6493edb576738/js/src/builtin/Promise.cpp#5146-5151,5164,5186-5187) (which corresponds to HostMakeJobCallback done in [PerformPromiseThen](https://tc39.es/ecma262/#sec-performpromisethen)) and associate it to the reaction
  * (2) Pass the additional `[[HostDefined]]` value to the embedding back when enqueueing the job
  * (2.1) Modify [JS::JobQueue::enqueuePromiseJob](https://searchfox.org/mozilla-central/rev/7e0ae4372c52b8183d1178132dd6493edb576738/js/public/Promise.h#56) to make it possible to pass the `[[SchedulingState]]` value (separate parameter, or maybe wrap incumbentGlobal and SchedulingState into single parameter to allow future extension)
  * (2.2) Modify the Gecko's side to store the `[[SchedulingState]]` value to the promise job (somewhere around [mozilla::CycleCollectedJSContext::enqueuePromiseJob](https://searchfox.org/mozilla-central/rev/7e0ae4372c52b8183d1178132dd6493edb576738/xpcom/base/CycleCollectedJSContext.cpp#250-251))
  * (3) Perform the additional [HostCallJobCallback](https://wicg.github.io/scheduling-apis/#sec-patches-html-hostcalljobcallback) steps
  * (3.1) Currently the incumbentGlobal handling is done before by [CallSetup](https://searchfox.org/mozilla-central/rev/7e0ae4372c52b8183d1178132dd6493edb576738/dom/bindings/CallbackObject.cpp#274,287) before calling the job, but in order to exactly follow the spec, the handling should be done as part of HostCallJobCallback, which is performed [inside the job](https://tc39.es/ecma262/#sec-newpromisereactionjob), only when the handler is not EMPTY.  So either modify the ordering, or somehow make it possible to perform the equivalent with the current CallSetup way


[17:41:12.0257] <arai>
and once that part is implemented, the task handling just need to set the current scheduling state to the specific value only during the sync execution of the task and unset it after that.  so that the scheduling state is stored to the reactions created during the sync execution, and propagated to the async promise-based execution

[06:23:08.0056] <mccr8>
Thanks for the explanation!

[09:36:23.0745] <jandem>
we now have a GitHub issue to track JSAPI changes for the next (ESR) Migration Guide for SM embedders. Please list breaking JSAPI changes here: https://github.com/mozilla-spidermonkey/spidermonkey-embedding-examples/issues/87

[11:17:48.0304] <sefeng>
thanks so much!! Will ping you back with more questions :) 

[13:58:17.0266] <sefeng>
arai: what should the scheduling state be, any C++ object or it needs to be a JS specific thing...?

[13:59:31.0995] <sefeng>
I guess from the DOM perspective, it should look like 
```
class WebTaskSchedulingState {
 private:
  Maybe<RefPtr<AbortSignal>> mAbortSource;
  Maybe<RefPtr<TaskSignal>> mPrioritySource;
};
```

[14:16:49.0518] <arai>
the restrictions here are the following:
  1. The state value needs to be stored into the [PromiseReactionRecord](https://searchfox.org/mozilla-central/rev/ce404cd26e52d09e6a48d664c1986da25df50484/js/src/builtin/Promise.cpp#729) object's slot.  This means it shoult be representable as `JS::Value` (so, `JSObject*`, or `JS::PrivateValue`, or some integer token, or something along that line)
  2. The state value is stored into a pending reaction, and it can be left pending until the page unload.
  3. The PromiseReactionRecord can be finalized off main thread.  If the state needs to be immediately freed upon finalization, the destructor might need to cover the case


[14:19:07.0169] <arai>
simple solution would be to create a JSObject (possibly with its own JSClass) that represents the entire `[[HostDefined]]` field and replace the "incumbentGlobal" handling with it, and let the object's finalize hook handle the refcount etc

[14:20:28.0647] <arai>
if the state persists until the page unload regardless of the task's lifetime, the other option would be to create an integer token on the embedding side and pass the token, so that you don't have to worry about the lifetime management


2024-10-06
[09:44:49.0516] <kemsguy7>
Hello everyone, I am Matthew Idungafa, an outreachy applicant and would love to contribute to this spidermonkey project. Please how can i get started? 

[09:45:38.0565] <syedbarimanjan>
> <@kemsguy7:mozilla.org> Hello everyone, I am Matthew Idungafa, an outreachy applicant and would love to contribute to this spidermonkey project. Please how can i get started?

join the "SpiderMonkey Outreachy" room.


2024-10-07
[02:51:46.0758] <smaug>
https://github.com/whatwg/html/pull/10528 might land relatively soon, unless we have still something to say about it

[03:11:07.0911] <zihco>
[Outreachy]  I had accidentally run `hg strip <current working directory parent's changeset-id>`, I have push my commit, the issue is that my commit is showing as new files rather than the changes i made. Please, what is the easiest way to fix this. Thanks

[03:40:30.0933] <jonco>
> <@smaug:mozilla.org> https://github.com/whatwg/html/pull/10528 might land relatively soon, unless we have still something to say about it

I'm OK with this although I haven't reviewed the latest changes

[03:50:58.0882] <smaug>
want to comment in the spec issue?

[04:33:14.0356] <arai>
zihco: are you still having the problem?  easiest way would be to discard your commit, pull from the remote, and apply the same change again and commit it as a new one.   if you want to keep your previous change, the way to recover totally depends on what you've modified.  so please provide more details

[06:56:14.0501] <jonco>
I did comment a couple of weeks ago

[06:56:37.0266] <jonco>
There have been a lot of changes since then so I was waiting for the spec to settle down again to give it another look

[07:17:42.0331] <Ms2ger>
anba: I wonder how the async parts of https://searchfox.org/mozilla-central/source/js/src/tests/non262/Promise/any-stack.js work. Shouldn't there be a drainJobQueue call?

[07:20:20.0813] <arai>
the job queue is drained after executing the top-level script

[07:21:04.0818] <arai>
`drainJobQueue` is for draining the job queue before proceeding to the remaining part of the testcase

[07:36:24.0843] <sefeng>
so should the `state` be `class SchedulingState : public NativeObject {}`? 

[07:36:31.0180] <sefeng>
 * so should the `state` be something like`class SchedulingState : public NativeObject {}`?

[07:38:12.0320] <arai>
it would depend on how much we implement the "HostDefined" things in SpiderMonkey (or make it customizable on the embedding side)

[07:39:45.0188] <sefeng>
oh right okay, so it'll be like class `HostDefined : public NativeObject {}`

[07:39:58.0622] <sefeng>
and I can store the state on that object directly? 

[07:40:08.0015] <arai>
If we make everything being outside of SpiderMonkey, we won't have dedicate class

[07:40:11.0840] <arai>
 * If we make everything being outside of SpiderMonkey, we won't have dedicate C++ class

[07:41:26.0391] <sefeng>
er, I don't understand what that means. 

[07:41:32.0072] <sefeng>
which do we prefer..?

[07:41:46.0868] <arai>
the consumer defines its own [JSClass](https://searchfox.org/mozilla-central/rev/b546e74055186bb387ed7db9079374e1e7e0b88e/js/public/Class.h#616), with reserved slots for each field (state,  incumbentGlobal, etc), and have the [JSClassOps::finalize](https://searchfox.org/mozilla-central/rev/b546e74055186bb387ed7db9079374e1e7e0b88e/js/public/Class.h#604) function to manage the lifetime of the pointed things

[07:43:42.0025] <arai>
yeah, that's the question. if we expect the "HostDefined" being extended more and more, or if the "state" handling is something more complicated than the current "incumbentglobal" handling, we would want to make the "HostDefined" handling being outside of SpiderMonkey

[07:44:53.0610] <arai>
there would be some kind of tradeoff (implementing inside SpiderMonkey might be simpler/faster, but putting more and more will complicate things unnecessarily), so it would depend on the needs

[07:47:08.0971] <sefeng>
I see, I prefer we make the "HostDefined" handling being outside of SpiderMonday. seems more "correct" to me. 

[07:48:03.0356] <sefeng>
I still don't understand what you meant by "outside of spidermoneky", is `making the customer defines its own JSClass` outside of spidermonkey?

[07:48:16.0382] <sefeng>
 * I still don't understand what you meant by "outside of spidermoneky", is `making the customer defines its own JSClass...` approach outside of spidermonkey?

[07:48:47.0764] <sefeng>
(due to my lack of understanding of SpiderMonkey)

[07:49:10.0569] <arai>
`NativeObject` is SpiderMonkey-internal class.  Outside of SpiderMonkey, all JS objects are represented as an opaque `JSObject*` pointer

[07:49:37.0082] <arai>
and all operations are done with JSAPI, such as [JS::GetReservedSlot](https://searchfox.org/mozilla-central/rev/b546e74055186bb387ed7db9079374e1e7e0b88e/js/public/Object.h#68) for accessing slots

[07:50:37.0720] <arai>
the slots is for storing data, such as a pointer for native (non-GC) objects

[07:50:59.0945] <arai>
the number of slots and some more details about how the object behaves are defined by `JSClass` above

[07:51:25.0960] <arai>
let me find simple example

[07:52:03.0977] <arai>
[mozilla::dom::SimpleGlobalClass](https://searchfox.org/mozilla-central/rev/b546e74055186bb387ed7db9079374e1e7e0b88e/dom/bindings/SimpleGlobalObject.cpp#60-86)

[07:52:07.0885] <sefeng>
it makes sense now, still create the "NativeObject" to define slots etc, but the handling of it is done with JSAPIs

[07:52:49.0905] <arai>
yes

[07:53:07.0013] <arai>
err, that example isn't appropriate.  it's a global object which has special behavior

[07:57:28.0303] <arai>
[mozilla::sWitnessClassOps](https://searchfox.org/mozilla-central/rev/b546e74055186bb387ed7db9079374e1e7e0b88e/toolkit/components/finalizationwitness/FinalizationWitnessService.cpp#110-124)

[07:58:15.0879] <arai>
it has reserved slots with ref-counted pointer, has finalize hook

[07:59:40.0614] <arai>
it's created with [JS_NewObject](https://searchfox.org/mozilla-central/rev/b546e74055186bb387ed7db9079374e1e7e0b88e/toolkit/components/finalizationwitness/FinalizationWitnessService.cpp#185), and the reserved slot is set by [JS_SetReservedSlot](https://searchfox.org/mozilla-central/rev/b546e74055186bb387ed7db9079374e1e7e0b88e/toolkit/components/finalizationwitness/FinalizationWitnessService.cpp#196-197), and the pointer is released by [the finalize hook](https://searchfox.org/mozilla-central/rev/b546e74055186bb387ed7db9079374e1e7e0b88e/toolkit/components/finalizationwitness/FinalizationWitnessService.cpp#93-94)

[08:02:13.0468] <arai>
so, in the same way, you can store all `HostDefined` data into an JSObject, and the JobQueue can pass it from/to SpiderMonkey when creating or running job callback, and the SpiderMonkey side doesn't have to touch the details of the `HostDefined` data

[08:03:48.0466] <sefeng>
sounds good, thanks. will get back later! 

[10:17:18.0460] <sefeng>
I am not sure how to get the fixed slot from the JSObject* 

[10:18:23.0396] <sefeng>
In `EnqueuePromiseReactionJob`, I wrote 
```
  if (JSObject* hostDefinedJobCallbackRecord =
          reaction->getAndClearHostDefinedJobCakkbackRecord()) {
    JSObject* objectFromIncumbentGlobal =
        hostDefinedJobCallbackRecord
            ->getFixedSlot(mozilla::INCUMENT_SETTING_SLOT)
            .toObjectOrNull();

    if (objectFromIncumbentGlobal) {
      objectFromIncumbentGlobal =
          CheckedUnwrapStatic(objectFromIncumbentGlobal);
      MOZ_ASSERT(objectFromIncumbentGlobal);
      global = &objectFromIncumbentGlobal->nonCCWGlobal();
    }

    webTasSchedulingState =
        hostDefinedJobCallbackRecord->getWebTaskSchedulingState();
  }

```
and this doesn't compile because `JSObject` doesn't have `getFixedSlot`

[10:18:46.0913] <sefeng>
 * In `EnqueuePromiseReactionJob`, I wrote

```
  Rooted<GlobalObject*> global(cx);
  Rooted<JSObject*> webTasSchedulingState(cx);
  if (JSObject* hostDefinedJobCallbackRecord =
          reaction->getAndClearHostDefinedJobCakkbackRecord()) {
    JSObject* objectFromIncumbentGlobal =
        hostDefinedJobCallbackRecord
            ->getFixedSlot(mozilla::INCUMENT_SETTING_SLOT)
            .toObjectOrNull();

    if (objectFromIncumbentGlobal) {
      objectFromIncumbentGlobal =
          CheckedUnwrapStatic(objectFromIncumbentGlobal);
      MOZ_ASSERT(objectFromIncumbentGlobal);
      global = &objectFromIncumbentGlobal->nonCCWGlobal();
    }

    webTasSchedulingState =
        hostDefinedJobCallbackRecord->getWebTaskSchedulingState();
  }

```

and this doesn't compile because `JSObject` doesn't have `getFixedSlot`

[10:21:21.0267] <sefeng>
 * In `EnqueuePromiseReactionJob`, I wrote

```
  Rooted<GlobalObject*> global(cx);
  Rooted<JSObject*> webTasSchedulingState(cx);
  if (JSObject* hostDefinedJobCallbackRecord =
          reaction->getAndClearHostDefinedJobCakkbackRecord()) {
    JSObject* objectFromIncumbentGlobal =
        hostDefinedJobCallbackRecord
            ->getFixedSlot(mozilla::INCUMENT_SETTING_SLOT)
            .toObjectOrNull();

    if (objectFromIncumbentGlobal) {
      objectFromIncumbentGlobal =
          CheckedUnwrapStatic(objectFromIncumbentGlobal);
      MOZ_ASSERT(objectFromIncumbentGlobal);
      global = &objectFromIncumbentGlobal->nonCCWGlobal();
    }
  }

```

and this doesn't compile because `JSObject` doesn't have `getFixedSlot`

[11:37:16.0080] <sefeng>
arai: ping ^, given I seem to have you around :) 

[11:38:41.0494] <arai>
[JS::GetReservedSlot](https://searchfox.org/mozilla-central/rev/b546e74055186bb387ed7db9079374e1e7e0b88e/js/public/Object.h#68) and [JS::SetReservedSlot](https://searchfox.org/mozilla-central/rev/b546e74055186bb387ed7db9079374e1e7e0b88e/js/public/Object.h#87)

[11:39:11.0867] <arai>
`JSObject` is opaque type outside of SpiderMonkey, and you need to use function-based JSAPI for all operations

[11:39:27.0811] <arai>
err, is it inside SpiderMonkey ?

[11:40:12.0743] <arai>
 * err, is the code inside SpiderMonkey ?

[11:40:40.0382] <sefeng>
this is https://searchfox.org/mozilla-central/rev/b546e74055186bb387ed7db9079374e1e7e0b88e/js/src/builtin/Promise.cpp#1553

[11:41:26.0883] <arai>
so, if we're to move the HostDefined things to the embedding, the existing incumbentGlobal handling should also be moved to the embedding

[11:42:11.0428] <arai>
so, instead of extracting the slot inside SpiderMonkey, just pass the `UserDefined` JSObject to the job queue methods

[11:42:58.0307] <sefeng>
ah okay, I thought I should extract them there

[11:43:49.0793] <arai>
afaik the incumbentGlobal object is just passed through without actually touching it inside SpiderMonkey, and wrapping it into the HostDefined object should work

[11:43:54.0816] <arai>
 * so, instead of extracting the slot inside SpiderMonkey, just pass the `HostDefined` JSObject to the job queue methods

[11:43:59.0440] <sefeng>
so..where should I extract them again?

[11:44:16.0885] <arai>
when the host wants the data

[11:44:57.0474] <arai>
somewhere around [mozilla::CycleCollectedJSContext::enqueuePromiseJob](https://searchfox.org/mozilla-central/rev/b546e74055186bb387ed7db9079374e1e7e0b88e/xpcom/base/CycleCollectedJSContext.cpp#239,241,245-247)

[11:45:58.0559] <sefeng>
ok, makes sense, thanks! 

[13:33:55.0320] <smaug>
sfink: do you happen to have some high level description somewhere for the worker GC stuff?

[13:45:52.0011] <smaug>
https://bugzilla.mozilla.org/show_bug.cgi?id=1822411 mccr8 

[13:47:17.0229] <mccr8>
Thanks. Yeah I looked at one of the patches a tiny bit. I think I'm monitoring phabricator changes to nsCycleCollector.cpp or something. There's a lot more patches, looks like!

[14:17:41.0024] <sfink>
The short comment in WorkerPrivate.cpp describes the basic approach. The final version of it is:
```
  // Set up timers to implement the Worker GC scheduling scheme:
  //
  //   (1) run a non-shrinking GC whenever eager limits are reached while the
  //   worker is running.
  //
  //   (2) if the worker goes idle and stays idle for IDLE_GC_DELAY_SEC, run a
  //   compacting GC.
  //
  //   (3) run a fallback GC occasionally while the worker is running.
  //
  // All of these GCs are incremental. Internally-triggered GCs from hitting a
  // hard threshold or due to zeal modes (for testing) are non-incremental.

```

[14:18:03.0554] <sfink>
(note that I'm not sure we really need the fallback GC)

[14:25:31.0453] <sfink>
Also, I've moved more towards never cancelling the timers when changing states, because in my test scenarios the states change way too often. So everything works by checking worker private state in the timeout callbacks and deciding whether to do something or kill the timer or whatever. So eg when going from Busy -> Idle, it'll set a member variable saying that we want an idle GC after now+5seconds. Then the timer callbacks will check that and see if it's time to GC. If there's a lot of Busy->Idle->Busy->..., then that trigger time will keep getting pushed out, but we won't repeatedly cancel and restart the timer; we'll just let it run, then when it fires decide whether to (1) run a GC, (2) reschedule it for a future time, or (3) just let it die. (1) is mIdleGCTime < now, (2) is mIdleGCTime > now, (3) is mIdleGCTime is null.

[15:11:31.0084] <kfjvj>
I have a question about interrupt callbacks.  Under what circumstances are they called other than API requests.

[15:11:41.0210] <kfjvj>
 * I have a question about interrupt callbacks.  Under what circumstances are they called other than API requests?

[15:21:36.0922] <kfjvj>
> <@kfjvj:matrix.org> I have a question about interrupt callbacks.  Under what circumstances are they called other than API requests?

I'm using an interrupt handler in my code, and I decided to count how many times it is called.  Strangely, it only seems to be called after I call JS_RequestInterruptCallback.

I expected that it would be called a number of times for other reasons, like garbage collection.


2024-10-08
[19:19:06.0680] <zihco>
> <@arai:mozilla.org> zihco: are you still having the problem?  easiest way would be to discard your commit, pull from the remote, and apply the same change again and commit it as a new one.   if you want to keep your previous change, the way to recover totally depends on what you've modified.  so please provide more details

Thanks @arai. Pulling from the remotes and applying the same change again works.

[19:20:14.0284] <zihco>
> <@arai:mozilla.org> zihco: are you still having the problem?  easiest way would be to discard your commit, pull from the remote, and apply the same change again and commit it as a new one.   if you want to keep your previous change, the way to recover totally depends on what you've modified.  so please provide more details

 * @arai:  thanks . Pulling from the remotes and applying the same change again works.

[19:20:38.0570] <zihco>
 * @arai  thanks . Pulling from the remotes and applying the same change again works.

[19:21:44.0319] <zihco>
 * @arai:mozilla.org  thanks . Pulling from the remotes and applying the same change again works.

[06:53:41.0866] <sefeng>
arai: there are two overrides for JobQueue::getHostDefinedJobCallbackRecord, do I need to worry about the one for `InternalJobQueue`?

[06:56:43.0242] <arai>
the internal one doesn't use the incumbent global object, so you can pass nullptr or something for `HostDefined` object

[06:57:23.0366] <arai>
but yeah, both overrides should be rewritten to use `HostDefined` object instead of incumbentGlobal object

[06:59:15.0815] <sefeng>
ok! thanks

[07:14:21.0812] <arai>
kfjvj: you can check the backtrace for the callback to see how the callback is called

[08:14:27.0310] <sefeng>
arai: how do I convert a `JSObject*` to a native object (`WebTaskSchedulingState`)

[08:14:51.0084] <arai>
what's the definition of WebTaskSchedulingState ?

[08:15:11.0414] <arai>
a C++ class that's completely unrelated to JSAPI ?

[08:15:33.0239] <sefeng>
yeah

[08:15:50.0342] <sefeng>
currently, it only looks like
```
class WebTaskSchedulingState {
  NS_INLINE_DECL_REFCOUNTING(WebTaskSchedulingState)
 private:
  ~WebTaskSchedulingState() = default;
};

```

[08:16:04.0192] <arai>
there's no way to "convert".  you need a JSObject that's holds the reference to the `WebTaskSchedulingState` instance

[08:16:32.0767] <arai>
see the above https://searchfox.org/mozilla-central/rev/b546e74055186bb387ed7db9079374e1e7e0b88e/toolkit/components/finalizationwitness/FinalizationWitnessService.cpp#110-124 case

[08:17:25.0827] <arai>
so, create a JSObject with your own JSClass that defines reserved slot, store a pointer to `WebTaskSchedulingState` as a PrivateValue to the reserved slot

[08:17:41.0307] <arai>
and get the reservet slot value and convert to PrivateValue and extract the pointer

[08:20:08.0354] <sefeng>
ah hmm...do you mind check what I've got so far https://phabricator.services.mozilla.com/D224959 

[08:20:17.0391] <sefeng>
so I extract it in `CycleCollectedJSContext::enqueuePromiseJob`

[08:20:53.0282] <sefeng>
and then pass it back as a JSObject to the callback...is that wrong?

[08:20:55.0204] <arai>
can you cc me on the revision?

[08:21:19.0044] <sefeng>
done!

[08:25:28.0073] <arai>
yeah, that looks going to the right direction. a refcount handling is needed tho.  Shall I add comments there?  or are you going to update shortly?

[08:25:40.0337] <sefeng>
please add comments!

[09:40:26.0606] <kfjvj>
> <@arai:mozilla.org> kfjvj: you can check the backtrace for the callback to see how the callback is called

I know that it's being called when I request a callback.  What confuses me is that I'm never seeing it be called in any other circumstance.

I'm trying to test my interrupt handler in many circumstances, so I'd like to know when else I should expect the interrupt handler to be called.

[09:51:24.0547] <kfjvj>
The fact that I'm not seeing any non-requested interrupt callbacks makes me wonder if my unit tests are not robust enough, and that maybe I should change them in such a way that the exercise a code path that would have more interrupt callbacks.

[09:51:43.0559] <kfjvj>
 * The fact that I'm not seeing any non-requested interrupt callbacks makes me wonder if my unit tests are not robust enough, and that maybe I should change them in such a way that they would exercise a code path that would have more interrupt callbacks.

[10:35:21.0058] <jandem>
kfjvj: that's expected. We also have various internal interrupts, but we only call the interrupt callback if you requested this through `JS_RequestInterruptCallback`

[10:35:56.0877] <jandem>
this was different before 1458567 (Firefox 61) when we didn't distinguish the different interrupt reasons

[10:38:40.0891] <jandem>
we have some testing mechanisms that might trigger interrupt callback calls too but you specifically have to enable that

[10:44:48.0899] <jandem>
 * kfjvj: that's expected. We do have various internal interrupts, but we only call the interrupt callback if you requested this through `JS_RequestInterruptCallback`

[11:14:18.0900] <arai>
oh, just realized, it's a draft revision which doesn't trigger notifications.  I've added comments

[13:02:30.0566] <sefeng>
arai: Thanks! and I'd also need to modify codegen right ? like https://searchfox.org/mozilla-central/rev/488d81581a9142d532bf814efa60564ff11599ca/dom/bindings/Codegen.py#20738-20739 

[13:04:45.0626] <arai>
at least that part isn't directly related to JSAPI.  but I assume that's for the subclasses of `CallbackObject` ?

[13:04:54.0150] <sefeng>
yeah

[13:05:35.0683] <sefeng>
because I added an additional parameter to the constructor of CallbackObject

[13:05:45.0034] <arai>
do they need a modification in term of the spec?

[13:06:38.0432] <arai>
if the additional parameter is specific to the promise reaction job, then I don't expect any change happens there

[13:06:56.0861] <arai>
maybe you can define a fallback behavior with default parameter with nullptr or something

[13:07:32.0150] <sefeng>
ok, that sounds good 

[13:07:34.0355] <arai>
if arbitrary callback needs to carry the "state" info, then they may need those changes, but I'm not sure

[13:08:15.0433] <sefeng>
ok, I'll start with a default null

[13:22:39.0500] <sefeng>
do I need to keep getIncumbentGlobal around because of https://searchfox.org/mozilla-central/rev/488d81581a9142d532bf814efa60564ff11599ca/js/src/builtin/FinalizationRegistryObject.cpp#692?

[13:53:03.0877] <smaug>
so what are "eager limits" ?

[13:53:49.0757] <smaug>
Is that just normal forced by JS-engine GC?

[13:54:32.0507] <smaug>
Hmm, so is the main difference to current behavior that everything is incremental ?

[15:58:14.0130] <arai>
that also needs to be rewritten with `[[HostDefined]]`

[16:00:38.0989] <arai>
that corresponds to https://tc39.es/ecma262/#sec-finalization-registry-cleanup-callback , which also uses HostMakeJobCallback

[16:00:58.0204] <arai>
so, that is also affected by the spec change

[16:01:05.0529] <arai>
sefeng: ^


2024-10-09
[08:42:34.0545] <sefeng>
arai: thanks, so I pass the hostDefinedData around, what about the the cleanup function? Do I need to modify it?

[08:43:14.0744] <sefeng>
eventually it's used at https://searchfox.org/mozilla-central/rev/7a85a111b5f42cdc07f438e36f9597c4c6dc1d48/js/src/gc/FinalizationObservers.cpp#305-310 

[10:14:23.0234] <arai>
yes. the ultimate consumer of that is also the embeddings, and I assume it also flows into CallbackObject or something 

[10:48:26.0985] <mgaudet>
üôèThank you Jan for writing the shape-teleporting test... it's the only test my patch fails, and there's no way I would have caught anything like this without it 

[10:48:46.0327] <mgaudet>
(Now to figure out -why- it's broken.... ) 

[12:30:56.0134] <arai>
the consumer is [mozilla::FinalizationRegistryCleanup::QueueCallback](https://searchfox.org/mozilla-central/rev/7db217e3832e9a884be0c2300779e098f92be3fe/xpcom/base/CycleCollectedJSContext.cpp#865), and the value is passed to [mozilla::dom::FinalizationRegistryCleanupCallback::FinalizationRegistryCleanupCallback](https://searchfox.org/mozilla-central/rev/7db217e3832e9a884be0c2300779e098f92be3fe/xpcom/base/CycleCollectedJSContext.cpp#911), which is `CallbackObject` subclass


2024-10-10
[02:41:13.0735] <jonco>
Is there a way to run specific sp3 subtests only?

[02:46:22.0377] <jonco>
seems like it's ?suite=foo

[03:00:23.0979] <julienw>
yes

[03:06:10.0914] <julienw>
jonco: secret trick: https://browserbench.org/Speedometer3.0/?developerMode

[03:06:27.0524] <julienw>
(it took me 10 minutes looking at the code to find it back)

[03:06:34.0688] <julienw>
 * (it took me 5 minutes looking at the code to find it back)

[03:06:50.0306] <jonco>
julienw: oh, thanks, that's really useful

[06:47:16.0794] <nbp>
jonco: any idea how to reproduce this windows issue on Linux: https://treeherder.mozilla.org/jobs?repo=autoland&group_state=expanded&resultStatus=pending%2Crunning%2Csuccess%2Ctestfailed%2Cbusted%2Cexception&fromchange=e2512fff5b956c782a5b60455ee3dcd28cf0f07a&searchStr=windows%2C2012%2Cx64%2Cdebug%2Cspidermonkey%2Cbuilds%2Cspidermonkey-sm-compacting-win64%2Fdebug%2Ccgc&tochange=97f6f83da563321fcc67174850e9027f0607370a&selectedTaskRun=b1FRRDEjSUm7Z7XiUQlxyw.0 ?

[07:13:40.0370] <jonco>
nbp: No idea. Your patch looks fine. The test might be hitting OOM but In don't know why this change would have triggered that.

[07:50:18.0123] <jonco>
 * nbp: No idea. Your patch looks fine. The test might be hitting OOM but I don't know why this change would have triggered that.

[09:29:48.0824] <nbp>
Fun, MFBT has a `BufferList` and a `SegmentedVector`, the `BufferList` implements an ordered set of segments allocated individually saved in a Vector, while the `SegmentedVector` implements an ordered set of segments allocated individually saved in a LinkedList.

[09:30:36.0523] <nbp>
 * Fun, MFBT has a `BufferList` and a `SegmentedVector`, the `BufferList` implements an ordered set of segments allocated individually and saved in a Vector, while the `SegmentedVector` implements an ordered set of segments allocated individually and saved in a LinkedList.

[09:40:21.0607] <sfink>
Yes, the JS engine GC forces an immediate, blocking GC when you hit certain "hard" limits. JS_MaybeGC has a lower threshold, so that you can run a GC before it's regarded as necessary by the hard limits. This can help if it's incremental, so that you don't have any long pauses and hopefully finish up before the hard limits are reached. Or it can help by timing the (blocking or not) GC to happen at a more convenient time.

[09:40:46.0569] <sfink>
but also yes, the main point of the whole patch stack is to make worker GC incremental. Or at least, as incremental as possible.

[09:41:38.0429] <sfink>
and both of them have an API that prevented me from using them when I needed something like that.

[09:42:02.0196] <sfink>
(well, not *prevented*, more like made it too much effort to bother with)

[09:50:18.0798] <sfink>
smaug: but note that I'm running into weird problems with that patch stack at the moment. I doubt I'll need to change any of the patches by a lot, but something is very wrong at the moment. (It runs great for a while, then the worker stops processing any events at all.) I'm working on fixing that, Maybe afterwards, we can have a call to discuss the series?

[10:33:38.0469] <smaug>
sfink: I was thinking to start going through the queue later today and tomorrow

[10:34:00.0781] <smaug>
Sorry about delay with that (well, I did look at some simple ones, but it was then a bit hard to see the big picture)

[10:35:00.0563] <sfink>
I can write something up after I fix this problem. (It's looking like a deadlock.)

[10:45:25.0811] <sfink>
and no worries about the delay, it turns out that it's not all fully baked yet!

[12:26:33.0322] <mgaudet>
I have a test that is quite delicate -- it pretty much needs no code to have run before the test itself. So it works fine if I just shell it, but if I try using the jit-test harness, the harness code itself seems to mess things up

[12:26:46.0540] <mgaudet>
I seem to recall we had a way to run tests like this... anyone remember?

[12:28:35.0261] <mgaudet>
ChatGPT hallucinates `raw`, but this also sort of sounds familiar

[12:42:26.0622] <mgaudet>
OK, spelunking through the code no such option exists... but I may make it exist 

[13:30:13.0027] <sefeng>
arai: Do you think I can put webtaskscheduling thingy in the separate patch, so that we can land the hostDefinedData first?

[13:30:21.0470] <sefeng>
it'll just wrap the incumbentGlobal 

[13:32:07.0499] <arai>
yeah, modifying the jobqueue + hostdefined part without changing any behavior will make it easier to handle any breakage 

[13:32:28.0237] <arai>
and that's also easier to review :)

[13:42:32.0266] <mgaudet>
confession: Knee deep in https://www.youtube.com/watch?v=AbSehcT19u0 

[13:42:34.0835] <botzilla>
Seen! Your update will eventually appear on https://robotzilla.github.io/histoire

[14:00:36.0980] <mgaudet>
confession: I... <del>I feel like I may have</del> definitely just built a bunch of infrastructure which could have been replaced with `newGlobal`. So that's nice. 

If anyone wants tests without prologues... I have patches. 

And don't need them anymore


2024-10-11
[07:24:33.0143] <Redfire>
If you `JS_DefineFunctions` the same `JSFunctionSpec` twice on two different objects, do they have the same pointer? (ie `obj1.func === obj2.func`)

[07:34:09.0334] <jandem>
Redfire: no, it will create new JS function objects the second time

[09:45:45.0030] <Bryan Thrall [:bthrall]>
My understanding is that Ion reuses some of the IC bytecode generated for Baseline, but I haven't tracked down where that happens. Am I remembering correctly?

[09:47:57.0656] <mgaudet>
Clarifying question: Recycling of the same IC stubs in Ion vs the same stub code? (I'm not actually sure if we do that! I feel like we may start the IC chains afresh in Ion)

[10:03:02.0481] <mgaudet>
An update on `JS_LOG`:[I've added an empty `debug` log module](https://phabricator.services.mozilla.com/D223796). The idea here being that for adding quick logging you don't intend to land, there's already a predefined module here for you to use. 

[10:04:31.0535] <tcampbell>
Bryan Thrall [:bthrall]: do you mean this? https://searchfox.org/mozilla-central/rev/0cd8e314881fc6c216586d1adc13eb8a03f5d040/js/src/jit/BaselineCacheIRCompiler.cpp#2561-2566
In baseline, we take the serialized cacheir as a key into a hashtable and see if we have machine code already

[10:32:11.0337] <mgaudet>
Huh. `./mach test-info failure-report --bug <intermittent bug>` is super nice. Surprised its not just on treeherder

[10:35:25.0284] <mgaudet>
(or heck, a bugzilla plugin) 

[12:15:00.0499] <Bryan Thrall [:bthrall]>
> <@tcampbell:mozilla.org> Bryan Thrall [:bthrall]: do you mean this? https://searchfox.org/mozilla-central/rev/0cd8e314881fc6c216586d1adc13eb8a03f5d040/js/src/jit/BaselineCacheIRCompiler.cpp#2561-2566
> In baseline, we take the serialized cacheir as a key into a hashtable and see if we have machine code already

I think it is not, since it looks like it's only related to Baseline.
I just found [WarpCacheIRTranspiler.](https://searchfox.org/mozilla-central/source/js/src/jit/WarpCacheIRTranspiler.cpp#40), which implies the answer to my question is wrong: Ion doesn't use the CacheIR directly. The CacheIR is transpiled instead.

[12:18:23.0731] <tcampbell>
oops, I misinterpreted your question. The transpiler seems what you are looking for. 
There is also `IonCacheIRCompiler` which is used _after_ an IonScript is generated, but there is a need to create new ICs that didn't exist when we did the original warp compile/transpile

[12:21:12.0864] <Bryan Thrall [:bthrall]>
 * I think it is not, since it looks like it's only related to Baseline.
I just found [WarpCacheIRTranspiler.](https://searchfox.org/mozilla-central/source/js/src/jit/WarpCacheIRTranspiler.cpp#40), which implies the answer to my question is "no": Ion doesn't use the CacheIR directly. The CacheIR is transpiled instead.

[13:01:30.0877] <arai>
oh, is this the thing that happens when you accidentally hit the video call button?

[13:01:38.0813] <tcampbell>
apparently...

[13:01:58.0243] <arai>
I was always thinking that button shouldn't be there

[13:03:32.0997] <arai>
it can easily be clicked accidentally

[13:05:01.0964] <mccr8>
It looks like only Admins can do it so at least it is limited.

[13:07:06.0899] <tcampbell>
ah, I was wondering if that was the case. It would still be nice to disable for the room

[13:57:31.0002] <arai>
I'm looking into the permission settings but I'm not sure which one corresponds to the video call


2024-10-12
[17:05:54.0894] <sfink>
confession: just burned an insane amount of time on something that looks like it's going to come down to a self-deadlock caused by gathering information for a debugging printout. üò¨

[17:05:58.0038] <botzilla>
Seen! Your update will eventually appear on https://robotzilla.github.io/histoire

[17:41:32.0026] <sfink>
yep, that was it. I mostly confused myself by creating the printout, `hg absorb`ing it deep into my patch stack, and then looking at the top patch or two and being baffled at how they could have possibly caused the problem.

[21:10:16.0782] <mayankleoboy1>
Why are webassembly-embenchen and webassembly-godot tests run only on m-c? 

[21:11:10.0448] <mayankleoboy1>
* Why are webassembly-embenchen and webassembly-godot tests run only on m-c? (as opposed to other tests like jetstream2/ares6 which are run more frequently?) 

[08:26:51.0382] <debadree25>
is there a way to print out stuff from within self hosted functions? so far have tried `print(...)` and `callContentFunction(console.log, "AsyncDisposableStack.prototype.disposeAsync");` ?

[08:36:04.0831] <evilpie>
> <@debadree25:mozilla.org> is there a way to print out stuff from within self hosted functions? so far have tried `print(...)` and `callContentFunction(console.log, "AsyncDisposableStack.prototype.disposeAsync");` ?

Look for `DumpMessage`


2024-10-14
[03:50:11.0952] <zombie>
> <@arai:mozilla.org> oh, is this the thing that happens when you accidentally hit the video call button?

I'm guessing this pinged everyone in the room?  I had a notification but can't find any mention otherwise

[03:59:41.0652] <zombie>
> <@arai:mozilla.org> oh, is this the thing that happens when you accidentally hit the video call button?

 * I'm guessing this pinged everyone in the room?  I had a notification but can't find any mention otherwise (in other words: if someone pinged me specifically, please try again)

[05:27:56.0308] <Ms2ger>
Yeah, that triggered a desktop notification for me as well

[10:55:54.0941] <shu>
anba: what is https://github.com/tc39/test262/blob/9b3d9d970047459dffdd4625d26295843ddd33b4/test/intl402/Intl/getCanonicalLocales/unicode-ext-canonicalize-timezone.js#L44 testing?

[10:57:20.0112] <shu>
specifically: this canonicalization seems to have changed with tz 2024b, and i'm wondering why that specific list was chosen in that test262 test

[11:06:37.0820] <anba>
shu: "EST" was used because it's also a valid IANA time zone identifier. 

[11:07:12.0205] <anba>
PR to update test262 is already prepared: https://github.com/tc39/test262/pull/4246

[11:07:17.0104] <shu>
ah, perfect

[11:07:17.0611] <shu>
thanks


2024-10-15
[05:20:56.0738] <Bas>
It would be nice if the profiler had markers for top level function invocations from Microtasks, Chrome provides this and it makes it a lot easier to see roughly what a microtask execution is 'doing' than looking at the call tree (i.e. this disregards ordering information and such)

[06:36:55.0537] <smaug>
Bas: That might get quite messy (because there can be so many microtasks around), but worth to try. But microtasks aren't a JS thing, so this would be more a question to DOM üòâ 

[06:37:24.0963] <smaug>
Bas: do you just want a new marker for microtasks or something else?

[06:37:43.0321] <Bas>
No for microtasks specifically, especially since I think a single microtask could invoke multiple functions.

[06:38:02.0784] <Bas>
So as I said, a marker for the top level function invocation that doesn't depend on being samples, like in Chrome devtools.

[06:38:10.0525] <Bas>
 * So as I said, a marker for the top level function invocation that doesn't depend on being sampled, like in Chrome devtools.

[06:38:29.0245] <padenot>
one for microtask checkpoint, one for every microtask

[06:38:29.0746] <smaug>
Usually a microtask triggers just one function. Promise callback or MutationObserver callback or so

[06:39:07.0232] <smaug>
padenot: ok, I'll try. The one for every microtask might add too much overhead, but we'll see

[06:39:23.0820] <padenot>
again, if there is overhead it's not a lot of work to make all of this free

[06:39:29.0466] <padenot>
we just need to invest some time

[06:40:06.0696] <padenot>
for a look at what is possible we can check all other systems like ours

[06:40:08.0792] <Bas>
To be fair, could be I'm wrong about how Chrome does it, might just be sampling at a higher frequency I guess.

[06:40:30.0201] <smaug>
I mean mostly how much overhead this would add when doing profiling

[06:40:44.0281] <smaug>
Some code must run when adding a marker

[06:41:02.0709] <padenot>
Bas: they do markers, if I'm thinking about the same thing you're talking about

[06:41:30.0595] <padenot>
but the key thing here is that they sort their markers in a better way so it's easier to understand causality and all that

[06:42:03.0993] <smaug>
ah, we have already AUTO_PROFILER_TRACING_MARKER("JS", "Perform microtasks", JS); for the top level one

[06:42:04.0884] <Bas>
Yeah, the fact that they represent the nesting does make it easier to see.

[06:42:27.0065] <Bas>
> <@smaug:mozilla.org> ah, we have already AUTO_PROFILER_TRACING_MARKER("JS", "Perform microtasks", JS); for the top level one

Indeed. but when nothing gets sampled during one it gives me no idea what it was doing.

[06:42:36.0391] <Bas>
See the perfteam channel for what I'm trying to figure out :)

[06:42:48.0835] <padenot>
it would be amazing to have the first stack frame name or something

[06:42:56.0601] <padenot>
at least

[06:43:00.0364] <Bas>
Yeah

[06:43:06.0645] <smaug>
Bas: ok, I don't know how to do that

[06:43:12.0662] <Bas>
Like the ScriptEvaluate marker.

[06:43:20.0206] <Bas>
But for the script invoked by the microtask.

[06:43:23.0371] <smaug>
We can add markers, but that doesn't mean we'd sample there

[06:43:51.0512] <padenot>
we have the tracer now as well, if we want to _understand_ something

[06:43:57.0568] <padenot>
(vs. measure accurately)

[06:45:24.0384] <smaug>
Bas: So you don't want microtask marker but perhaps promise callback marker (or MutationObserver callback marker), or queueMicroTask callback marker

[06:45:34.0677] <Bas>
I suppose so.

[06:46:01.0082] <padenot>
his screenshot has both, but also more stack frames

[06:48:47.0684] <Bas>
> <@padenot:mozilla.org> his screenshot has both, but also more stack frames

Sure but that's just sampling I'm guessing.

[06:48:49.0677] <smaug>
That screenshot has out current top level marker + callbacks

[06:49:01.0153] <smaug>
 * That screenshot has our current top level marker + callbacks

[06:49:29.0609] <smaug>
(I don't know what "evaluate scripts" means there. Microtasks aren't only about scripts)

[06:50:01.0637] <Bas>
That's their top level marker.

[06:50:02.0720] <smaug>
oh, perhaps there was some script running, and at the end of that microtasks are shown that way?

[06:50:23.0677] <Bas>
Indeed.

[06:50:40.0714] <padenot>
maybe if they do taskA that runs script, then microtask checkpoint, then TaskB also runs some script they put all this under a marker

[06:53:12.0304] <smaug>
Bas: do you know if they really show all the callbacks there?  Maybe I should test.

[06:53:53.0475] <Bas>
> <@smaug:mozilla.org> Bas: do you know if they really show all the callbacks there?  Maybe I should test.

I kind of doubt it, but I'm not sure.

[06:57:35.0011] <smaug>
they don't

[06:58:14.0943] <smaug>
In my test I triggered 100 callbacks and all those get merged to one "(anonymous)"

[06:58:38.0527] <Bas>
Maybe because it's one sample?

[06:59:01.0705] <smaug>
I don't know how to see samples in Chrome's tools

[07:00:14.0438] <Bas>
I don't think they make it explicit.

[07:01:11.0715] <Bas>
(Like markers and samples are completely interleaved in their call tree afaict)

[11:17:24.0700] <debadree25>
is there anyway to assert that the particular CacheIR stub i want executed is indeed executed?

[12:07:06.0168] <mgaudet>
debadree25: Not a great one. For development, i will use writer.breakpoint() just before the final operation; then if I run a test case under the debugger and the breakpoint happens I know we got there

[12:07:24.0893] <mgaudet>
which is slightly dissatisfying, but that's what I've got alas :)

[12:09:15.0156] <debadree25>
ohh i see thank you! but now way to like write a jit-test. I thought i fixed an issue but turns out i the stub just stopped attaching lol

[12:10:36.0791] <debadree25>
 * ohh i see thank you! but no way to like write a jit-test. I thought i fixed an issue but turns out i the stub just stopped attaching lol

[12:10:57.0509] <debadree25>
 * ohh i see thank you! but no way to like write a jit-test. I thought i fixed an issue but turns out i just stopped the stub from attaching

[12:12:17.0234] <mgaudet>
/me nods 

[12:12:40.0572] <mgaudet>
I don't know we have a good answer here really.


2024-10-16
[04:18:45.0521] <emilio>
What is a `BackstagePass`? Which code runs in that global?

[04:18:55.0633] <emilio>
smaug: ^ do you happen to know?

[04:19:51.0834] <emilio>
/me tracking down a devtools leak but would be good to narrow down which of all the `addObserver` calls leak :)

[04:24:26.0394] <emilio>
Seems like something something where modules are imported?

[04:25:15.0022] <emilio>
So one of these? https://searchfox.org/mozilla-central/search?q=obs.addObserver%28&path=devtools%2F**.mjs&case=false&regexp=false

[04:30:28.0458] <@allstarschh>
jon4t4n: ping about your bug 1858078, which part is blocking you? CSP, Request.destination or the preload part ?

[04:30:31.0029] <botzilla>
https://bugzil.la/1858078 ‚Äî NEW (nobody) ‚Äî Implement changes to JSON&CSS modules loading

[04:46:33.0294] <jon4t4n>
@allstarschh: The preload part. The WIP patch attached to the bug should make the destation and CSP tests pass.

[04:50:34.0863] <jon4t4n>
 * @allstarschh: The preload part. The WIP patch attached to the bug should make the destination and CSP tests pass.

[05:13:43.0143] <@allstarschh>
jon4t4n: I just tested with your patch, in my local run connect-src-json-import-blocked.sub.html, fetch-destination.https.html also failed

[05:14:32.0918] <@allstarschh>
jon4t4n:  but anyway, I'll help to check the preload part 

[05:18:11.0665] <@allstarschh>
and when testing fetch-destination.https.html, I think there's a bug for passing the CompileOptions to compile the json module, I get "import assertions are not currently supported" even I have enabled the pref in .ini

[05:43:08.0405] <jon4t4n>
@allstarschh: I am not confident at all in that WIP patch, so I might have broken a few test cases that I thought passed earlier. But I would be surprised if there is a bug in the pref handling because we have a lot of other web platform tests enabled for import attributes and JSON modules, and they seem to work.

[05:47:14.0898] <@allstarschh>
> <@jon4t4n:mozilla.org> @allstarschh: I am not confident at all in that WIP patch, so I might have broken a few test cases that I thought passed earlier. But I would be surprised if there is a bug in the pref handling because we have a lot of other web platform tests enabled for import attributes and JSON modules, and they seem to work.

okay, I'll also check why I got ""import assertions are not currently supported" 

[05:55:41.0219] <smaug>
I never recall which things uses Sandbox and which BackstagePass, and looks like the latter is for js modules. Oh, I see, devtools use that too for something. No idea for what

[05:56:33.0076] <smaug>
but bug 1790383 explains that

[05:56:33.0991] <botzilla>
https://bugzil.la/1790383 ‚Äî RESOLVED (ochameau) ‚Äî Allow loading ESM in a distinct system compartment

[05:59:05.0079] <ochameau>
`BackstagePass` is the shared system JS global, used by former JSMs and now all the ES Modules. (this isn't devtools specific)

[06:00:12.0528] <ochameau>
DevTools spawn a distinct JS global, but only when using the Browser Toolbox. To load the DevTools server in a distinct compartment and load modules distinctly from the debugged firefox modules. So that we don't share any state.

[06:00:39.0188] <ochameau>
AFAIK, that distinct JS global is also named `BackstagePass`.

[09:51:49.0891] <kfjvj>
Does anyone know what might cause this assert statement to fail?

https://searchfox.org/mozilla-central/source/js/public/RootingAPI.h#1223

[09:52:11.0067] <kfjvj>
 * Does anyone know what might cause this assert statement to fail?

```
~Rooted() {
    MOZ_ASSERT(*this->stack == this);
    *this->stack = this->prev;
  }
```

https://searchfox.org/mozilla-central/source/js/public/RootingAPI.h#1223

[09:57:15.0596] <arai>
when you allocate Rooted on heap, it will fail

[09:59:29.0355] <arai>
or do anything that breaks the LIFO order for the lifetime of Rooted, it fails

[10:01:24.0158] <kfjvj>
Do you mean LIFO order relative to other rooted objects?

[10:02:48.0854] <arai>
other Rooteds

[10:03:18.0513] <arai>
to be clear, this is not about the objects pointed by Rooted

[10:03:39.0410] <arai>
but the Rooted instance itself

[10:07:00.0695] <sfink>
We should make that something like `MOZ_ASSERT(*this->stack == this, "Rooted instances must be destroyed in reverse order of creation");` or something. Would that have explained it well enough? Or is it better to say "in LIFO order"?

[10:07:15.0113] <sfink>
(or both)

[10:42:16.0710] <sfink>
jonco: that [wikipedia page](https://en.m.wikipedia.org/wiki/Percentile) spells it out pretty directly, and even says "The simplest are nearest-rank methods... although compared to interpolation methods, results can be a bit crude." I'm curious, can you point me to the closed github issue?

[10:43:34.0402] <sfink>
istm that some form of interpolation would be valid as long as we can claim the underlying distribution is continuous, which it is

[10:54:14.0602] <Ryan Hunt>
do we have any way of getting an estimate of the total memory on the system we're on? I'd like to know when we may be on a low memory system to Ion compiling some large functions

[11:00:33.0033] <mgaudet>
Would someone with website access be able to stamp and land this pull request to make sure Jan's name shows up at the -top- of his awesome blog post: https://github.com/mozilla-spidermonkey/spidermonkey.dev/pull/186 

[11:05:50.0480] <jonco>
sfink: https://github.com/mozilla/glam/issues/2054

[11:07:27.0433] <jandem>
done. Thanks. I didn't know about this feature :)

[11:07:37.0017] <jandem>
 * done. Thanks, I didn't know about this feature :)

[11:52:58.0976] <sfink>
jonco: I'm [trying again](https://github.com/mozilla/glam/issues/2985)

[11:53:45.0565] <sfink>
it looked to me like the issue got closed not because they didn't want to do it, but because a change landed that referenced the other temporal smoothing thing that I wish they hadn't done.

[11:54:06.0666] <sfink>
so the issue got taken over by that change, somewhat accidentally

[12:29:56.0449] <debadree25>
wow 75x üöÄüöÄüöÄüöÄ great post!


2024-10-17
[03:35:03.0293] <mayankleoboy1>
https://www.howtogeek.com/firefox-75x-faster-running-webassembly/

[06:03:56.0248] <@allstarschh>
dminor: meeting?

[06:11:59.0832] <dminor>
Sorry, running late :(

[10:13:23.0734] <dminor>
Ms2ger: Thanks for the non262 test fixes :) Do you still have commit privileges, or should I land them for you?

[11:58:03.0689] <sefeng>
arai: I now have something that compiles but crashes right away when calling mozilla::dom::GetIncumbentGlobal() 

[11:58:19.0485] <sefeng>
I've got a pernosco record, do you mind help me to figure it out? 

[11:59:02.0703] <arai>
sure

[11:59:07.0174] <sefeng>
I doubt the issue is within `GetIncmbentGlobal()` because I didn't really tough it. Maybe I didn't store the it correct? 

[11:59:12.0288] <sefeng>
[here](https://pernos.co/debug/ux3rRBXfXe74uoqvZjISsw/index.html#f{m[qak,BJTVsg_,t[QQ,De8d_,f{e[qak,BJTVgQ_,s{af+KL5RAA,bD28,uAStvIQ,oATPCkA___/)

[12:05:44.0418] <aosmond>
did I misimplement the cycle collection traversing somehow or perhaps misunderstand the expected lifetimes in this JS excerpt from https://bugzilla.mozilla.org/show_bug.cgi?id=1925072#c7 ?

[12:06:50.0169] <aosmond>
the ImageDecoder object (the `decoder` JS variable) is getting unlinked seemingly before `const { image } = await decoder.decode();` finishes

[12:07:05.0610] <aosmond>
I never get the `decoder.close();` call in the line after

[12:07:39.0623] <aosmond>
if I force the object to stay alive through a strong pointer in the promise callbacks, everything works as expected

[12:09:09.0963] <arai>
what's the diff right now?

[12:09:35.0471] <aosmond>
(the bug comments link the relevant C++ code)

[12:10:26.0944] <sefeng>
arai: updated https://phabricator.services.mozilla.com/D224959

[12:10:48.0158] <arai>
somehow the global's reserved slot contains a ObjectValue, while the code expects a PrivateValue

[12:13:22.0306] <sefeng>
it should be an objectvalue I think? I don't know where it expects a PrivateValue..

[12:14:01.0077] <arai>
the `JS::GetMaybePtrFromReservedSlot` frame expects PrivateValue

[12:14:07.0256] <mccr8>
> <@aosmond:mozilla.org> did I misimplement the cycle collection traversing somehow or perhaps misunderstand the expected lifetimes in this JS excerpt from https://bugzilla.mozilla.org/show_bug.cgi?id=1925072#c7 ?

This is more of a #dom:mozilla.org question than a #spidermonkey:mozilla.org question. A WeakPointer won't hold something alive. I'm not sure exactly what the problem is here but I can read it more.

[12:14:15.0759] <arai>
I see the object in the slot being a BackstagePass

[12:15:16.0762] <aosmond>
yeah I don't expect my WeakPtr in C++ to keep it alive. I was expecting the JS side to keep the ImageDecoder alive though.

[12:16:01.0637] <aosmond>
certainly I am now asking myself the question, did I do the right thing here, and the promise should still be fulfilled if the last ImageDecoder reference in JS goes away

[12:16:42.0118] <aosmond>
but I'm a bit puzzled how it could have gotten GC'd, given it seems like there is code just below the `decode()` call that should still need the object alive?

[12:16:47.0254] <arai>
while the owner of the slot is also BackstagePass, and the slot contains the same object

[12:16:54.0116] <kfjvj>
Does the mozjs library have built-in support for the Set data type?

[12:17:35.0712] <mccr8>
> <@aosmond:mozilla.org> but I'm a bit puzzled how it could have gotten GC'd, given it seems like there is code just below the `decode()` call that should still need the object alive?

So the object being freed is the same as `const decoder`?

[12:18:19.0876] <arai>
`JS_SetReservedSlot(incumbentGlobal, INCUMENT_SETTING_SLOT,` in the diff is the culprit

[12:18:29.0149] <arai>
the 1st parameter should be `objResult`

[12:18:31.0038] <aosmond>
yes

[12:20:07.0214] <aosmond>
I think I can see a problem with my C++ impl without the `decoder.close()` line. presumably if the caller only saved the promise, then I need to internally keep `decoder` alive long enough to fulfill the promise. but am I wrong in thinking that the `decoder.close()` should have kept it alive in this particular case?

[12:21:52.0857] <mccr8>
> <@aosmond:mozilla.org> I think I can see a problem with my C++ impl without the `decoder.close()` line. presumably if the caller only saved the promise, then I need to internally keep `decoder` alive long enough to fulfill the promise. but am I wrong in thinking that the `decoder.close()` should have kept it alive in this particular case?

I would have thought so. Keep in mind the `decoder` is the JS reflector and not the actual C++ object but it should keep it alive. You could look at a cycle collector log and that might show why it was freed. Or help get an idea of what is going on.

[12:23:52.0768] <aosmond>
okay thanks. I'll dig in on the cycle collector side. didn't want to waste my time if I was just missing something obvious :).

[12:34:27.0697] <kfjvj>
In case anyone missed it above, I will reiterate: Does mozjs have any built-in support for a Set datatype?  I know it has support for a Map datatype.

[12:39:09.0720] <sefeng>
ah! thanks 

[12:43:52.0764] <arai>
what kind of support?

[13:14:21.0282] <arai>
aosmond: the JS side doesn't automatically keep the local variables alive. the local variables are held by the async function's continuation, which is held by a promise reaction, which is held by the promise returned by decoder. so, unless there's any other thing that holds decoder, everything gets collected 

[13:16:33.0935] <aosmond>
oh okay, very good to know then. my WeakPtr usage actually caused this entire problem then, because the engine ultimately expected the outstanding promise to keep the decoder alive.

[13:19:33.0351] <kfjvj>
> <@arai:mozilla.org> what kind of support?

Never mind.  I can see that Map and set both have functions defined in the header MapAndSet.hpp

[13:30:23.0745] <sefeng>
arai: so er, now it just shows up a blank page. I noticed the `global` I get in`CycleCollectedJSContext::enqueuePromiseJob` is once again a `BackstagePass`

[13:30:44.0739] <sefeng>
 * arai: so er, now it just shows up a blank window. I noticed the `global` I get in`CycleCollectedJSContext::enqueuePromiseJob` is once again a `BackstagePass`

[13:31:26.0786] <sefeng>
but the code looks fine?
```nsIGlobalObject* global = nullptr;
if (hostDefinedData) {
    JS::Value incumbentGlobal =
        GetReservedSlot(hostDefinedData, mozilla::INCUMENT_SETTING_SLOT);
    if (incumbentGlobal.isObject()) {
      global = xpc::NativeGlobal(&incumbentGlobal.toObject());
    }
```

[13:31:36.0844] <sefeng>
 * but the code looks fine?

```
nsIGlobalObject* global = nullptr;
if (hostDefinedData) {
    JS::Value incumbentGlobal =
        GetReservedSlot(hostDefinedData, mozilla::INCUMENT_SETTING_SLOT);
    if (incumbentGlobal.isObject()) {
      global = xpc::NativeGlobal(&incumbentGlobal.toObject());
    }
```

[13:35:45.0983] <arai>
the global being `BackstagePass` is okay

[13:36:17.0490] <arai>
the previous problem was that the code was modifying the global unexpectedly

[13:36:35.0007] <sefeng>
ah okay...

[13:36:44.0277] <sefeng>
do you have suggestions about how to debug this..

[13:37:11.0721] <arai>
do you mean "a blank window" is the problem?  what do you expect it to be?

[13:37:20.0888] <sefeng>
yeah, it stucks with a blank window

[13:37:34.0946] <sefeng>
I checked the event loop just idle 

[13:37:50.0149] <arai>
is it that the browser window has no UI ?

[13:37:54.0992] <sefeng>
yeah

[13:40:24.0375] <arai>
is there any change from the patch on phabricator than the `JS_SetReservedSlot` line?

[13:41:27.0093] <sefeng>
nope

[13:41:33.0617] <sefeng>
just only that change

[13:42:21.0087] <arai>
Just make sure, are you running a debug build with assertions enabled?  do you see any assertion failure in any process?

[13:43:01.0104] <sefeng>
yeah debug build, no assertion failures 

[13:49:39.0666] <arai>
The FinalizationRegistryCleanup::QueueCallback seems to be using the hostDefined object as incumbentGlobal

[13:49:54.0897] <arai>
that part needs update

[13:50:45.0128] <arai>
Also, I see `mCallback->Call("promise callback");` line gets removed by the patch

[13:51:14.0384] <arai>
the latter looks more related

[13:52:05.0918] <sefeng>
ah darn, that's huge...

[13:52:12.0769] <sefeng>
that fixes it!

[13:52:36.0649] <sefeng>
thanks!


2024-10-18
[00:33:58.0211] <zhaolikun>
Hello, I have an issue with building mozjs deb package in riscv-v with DEB_CFLAGS_MAINT_APPEND += -DCAN_USE_RVV. Could you tell me how to fix this.
Detailed error messages could be found at the link https://github.com/servo/mozjs/issues/513


[00:44:53.0550] <arai>
zhaolikun: I don't think that configuration is tested.  we don't have CI for riscv, and it's maintained by external contributor

[00:48:24.0808] <arai>
in term of "how to fix", easy option would be to omit the flag.  the other way would be to address each compile error and fix the code.  patches are welcome :)

[00:51:12.0428] <zhaolikun>
Thanks~

[02:28:57.0592] <Ms2ger>
> <@dminor:mozilla.org> Ms2ger: Thanks for the non262 test fixes :) Do you still have commit privileges, or should I land them for you?

I think I still do. Thanks!

[06:36:02.0477] <sefeng>
arai: re `FinalizationRegistryCleanup::QueueCallback`, should I use hostDefined object or incumbentGlobal? 

[06:36:39.0766] <arai>
hodtdefined

[06:36:59.0657] <sefeng>
so [here](https://searchfox.org/mozilla-central/rev/e24f7f322960a39f9ef644a31b6026994db73850/xpcom/base/CycleCollectedJSContext.cpp#941) should be the hostdefined object?

[06:37:36.0133] <arai>
yes. I thought a caller is already rewritten

[06:38:36.0512] <sefeng>
okay, thanks! 

[09:03:05.0061] <Ms2ger>
> <@dminor:mozilla.org> Ms2ger: Thanks for the non262 test fixes :) Do you still have commit privileges, or should I land them for you?

I was waiting for linting to finish to land bug 1924541 (had to fix a merge conflict), but I'm heading out for the weekend now - feel free to push it if you have time later, otherwise I'll do it on Monday

[09:03:07.0553] <botzilla>
https://bugzil.la/1924541 ‚Äî ASSIGNED (Ms2ger) ‚Äî Several bugs in non262 tests

[13:42:05.0507] <kfjvj>
Can someone explain the difference between these functions for sets?

```
extern JS_PUBLIC_API bool SetKeys(JSContext* cx, HandleObject obj,
                                  MutableHandleValue rval);

extern JS_PUBLIC_API bool SetValues(JSContext* cx, HandleObject obj,
                                    MutableHandleValue rval);

extern JS_PUBLIC_API bool SetEntries(JSContext* cx, HandleObject obj,
                                     MutableHandleValue rval);
```

[13:42:51.0618] <kfjvj>
 * Can someone explain the difference between these functions for sets?

```
extern JS_PUBLIC_API bool SetKeys(JSContext* cx, HandleObject obj,
                                  MutableHandleValue rval);

extern JS_PUBLIC_API bool SetValues(JSContext* cx, HandleObject obj,
                                    MutableHandleValue rval);

extern JS_PUBLIC_API bool SetEntries(JSContext* cx, HandleObject obj,
                                     MutableHandleValue rval);
```

I understand how they would be different for maps.  But it seems to me that there should be no distinction between keys, values, and entries in a set.

[13:44:16.0319] <sfink>
I think it just mirrors the JS API. `s.keys()` returns the same thing as `s.values()`. `s.entries()` returns something that sort of pretends keys are mapped to themselves.

[13:44:54.0367] <sfink>
```js
js> s = new Set([10,20,30])
({})
js> s.keys()
({})
js> [...s.keys()]
[10, 20, 30]
js> [...s.values()]
[10, 20, 30]
js> [...s.entries()]
[[10, 10], [20, 20], [30, 30]]
```

[13:45:06.0649] <arai>
SetKeys is equivalent to SetValues ([ref](https://searchfox.org/mozilla-central/rev/ec82d34b786f309f9901efe989d59cb55bd61cf0/js/src/builtin/MapObject.cpp#2132-2134)

[13:45:11.0047] <arai>
 * SetKeys is equivalent to SetValues ([ref](https://searchfox.org/mozilla-central/rev/ec82d34b786f309f9901efe989d59cb55bd61cf0/js/src/builtin/MapObject.cpp#2132-2134))

[13:46:27.0935] <kfjvj>
> <@arai:mozilla.org> SetKeys is equivalent to SetValues ([ref](https://searchfox.org/mozilla-central/rev/ec82d34b786f309f9901efe989d59cb55bd61cf0/js/src/builtin/MapObject.cpp#2132-2134))

So what kind of object should I expect in the return value?  More specifically, how should I go about iterating over the values?

[13:48:17.0078] <sfink>
are you using these as a C++ map/set? They're not very good for that; they're really implementing a JS Map/Set. If you want something for C++, it'd be better to use something like `GCHashMap`/`GCHashSet` (assuming your keys or values are GC things).

[13:48:35.0958] <arai>
It returns a Set Iterator object, and you're supposed to perform the regular iteration protocol to iterator over it

[13:49:08.0751] <arai>
but yeah, if it's used only in C++ side and the object is not exposed to JS side, then using the Set built-in might not be the right choice

[13:49:43.0564] <sfink>
```js
js> s.keys().__proto__.constructor
function Iterator() {
    [native code]
}
js> s.keys().next()
({value:10, done:false})
```

[13:50:03.0773] <kfjvj>
Can I use a JS::ForOfIterator?

(btw the point is to convert between JS sets and std::set.  I have to use set objects)

[13:51:15.0710] <sfink>
yes, I would guess that would be a lot easier than doing the iteration yourself

[13:51:26.0877] <sfink>
 * yes, I would guess `JS::ForOfIterator` would be a lot easier than doing the iteration yourself

[13:52:25.0120] <sfink>
admittedly, I hadn't known of its existence. arai knows, though; I can see that they reviewed it!

[13:52:33.0830] <sfink>
(not that I remember 80% of the things I review, but arai would.)

[13:55:02.0073] <arai>
I forgot about that class :P


2024-10-19
[23:34:55.0785] <timvde>
Just a small FYI about https://spidermonkey.dev/blog/2024/10/16/75x-faster-optimizing-the-ion-compiler-backend.html
The link "immediate dominator" (towards https://en.wikipedia.org/wiki/Dominator_(graph_theory)) is broken

[12:29:53.0469] <debadree25>
the hacking tips over [here](https://searchfox.org/mozilla-central/source/js/src/doc/hacking_tips.md#548)  says to set a breakpoint at `js_failedAllocBreakpoint` i did build with `--enable-debug` and `--enable-oom-breakpoint` but in lldb when i try do `breakpoint set --method js_failedAllocBreakpoint` but i get `Breakpoint 1: no locations (pending).` what could i be doing wrong üòÖüòÖ

[12:49:38.0226] <arai>
debadree25: `b js_failedAllocBreakpoint` and `breakpoint set --name js_failedAllocBreakpoint` works here.  I assume `--method` means actual class/instance method, instead of function?

[12:51:10.0376] <debadree25>
oh we can do directly `b js_failedAllocBreakpoint` üòÖü§¶ argh i think i just confused things thank you! yes this works!

[12:55:07.0199] <arai>
Thanks!  opened PR in https://github.com/mozilla-spidermonkey/spidermonkey.dev/pull/187


2024-10-20
[11:04:11.0076] <timvde>
Oh, I didn't know the blogs were in Github! I'll open a PR myself next time :)


2024-10-21
[05:43:56.0588] <jandem>
gkw: thanks for reporting these exception handling assertion failures. Do you have many of these left? This assertion has been effective at flushing out very old OOM bugs

[05:44:31.0459] <jandem>
 * gkw: thanks for reporting these exception handling assertion failures. Do you have many of these left? This assertion has been effective for flushing out very old OOM bugs

[06:58:48.0591] <davidj361>
I've noticed that executing stencils can be slower than EvaluateScripts, what are some performance boosts I could do? Also can you make stencils execute in compartments instead?

[07:00:27.0543] <sefeng>
arai: so er, does it mean that I should make https://searchfox.org/mozilla-central/rev/ec342a3d481d9ac3324d1041e05eefa6b61392d2/dom/bindings/CallbackFunction.h#29-30 a hostDefined object?

[07:01:14.0533] <sefeng>
because `FinalizationRegistryCleanupCallback` is just a `CallbackFunction`?

[07:03:19.0867] <arai>
I thought, the change affects the callback semantics, and the `[[SchedulingState]]` is necessary for callback setup

[07:03:36.0586] <arai>
if that's the case, then yes, those parts also need to be modified

[07:04:56.0134] <arai>
that part can be split into separate patch tho

[07:06:14.0645] <arai>
uh, there are so many buttons that can be accidentally clicked :P

[07:06:49.0675] <sefeng>
ah I see, I'll do that in a separate patch

[07:06:56.0961] <arai>
davidj361: can you provide more details?

[07:08:37.0954] <arai>
the part that receives HostDefined as `JSObject` should be updated to interpret it as HostDefined instead of IncumbentGlobal, but once it extracts nsIGlobalObject, the part after that can be in separate patch

[07:09:27.0092] <arai>
I'm not aware of any situation where using stencil can directly affect the performance

[07:09:32.0964] <davidj361>
> <@arai:mozilla.org> davidj361: can you provide more details?

JS_EvaluateScript is faster by some like 200ms than std::filesystem read + JS::DecodeStencil + JS_ExecuteScript

[07:10:26.0106] <arai>
why is the time taken by file system access is added only to the latter?

[07:12:18.0964] <arai>
also, which API do you mean by JS_EvaluateScript ?  That name doesn't exist.

[07:13:46.0655] <arai>
`JS::Evaluate` ?

[07:14:50.0722] <sefeng>
arai: I don't think I follow that. Is that somewhere in my patch? I think I was also confused when you mention it last time...

[07:14:53.0692] <sefeng>
 * arai: I don't think I follow that. Is that somewhere in my patch? I think I was also confused when you mentioned it last time...

[07:15:07.0766] <davidj361>
> <@arai:mozilla.org> `JS::Evaluate` ?

Yes, sorry

[07:15:28.0351] <arai>
if so, the former is using on-memory text as JS source, compile it to Stencil, and then instantiate it to JSScript, and execute it.  the latter is reading the XDR data from disk, decode it to Stencil, and then instantiate it to JSScript, and execute it

[07:15:54.0996] <arai>
the reading the data from disk part would take much time

[07:16:01.0704] <arai>
 * the "reading the data from disk" part would take much time

[07:18:41.0142] <arai>
it's about `JS::SetHostCleanupFinalizationRegistryCallback` API.  that takes a callback function, that's [mozilla::FinalizationRegistryCleanup::QueueCallback](https://searchfox.org/mozilla-central/rev/ec342a3d481d9ac3324d1041e05eefa6b61392d2/xpcom/base/CycleCollectedJSContext.cpp#890,894) in this case

[07:19:06.0432] <arai>
the function is currently taking `JSObject* aIncumbentGlobal`.  and that part is not touched by your patch

[07:19:39.0742] <arai>
the callback function is stored into [js::gc::GCRuntime::hostCleanupFinalizationRegistryCallback](https://searchfox.org/mozilla-central/rev/ec342a3d481d9ac3324d1041e05eefa6b61392d2/js/src/gc/GC.cpp#1646), and used by [js::gc::GCRuntime::callHostCleanupFinalizationRegistryCallback](https://searchfox.org/mozilla-central/rev/ec342a3d481d9ac3324d1041e05eefa6b61392d2/js/src/gc/GC.cpp#1649,1654)

[07:20:00.0242] <arai>
the latter part is modified by your patch to pass the hostDefined data

[07:20:06.0955] <arai>
so, there's mismatch

[07:21:09.0367] <davidj361>
I don't get it because I thought stencils were created for the purpose of saving as a cache to the disk to improve times

[07:21:36.0743] <arai>
the 2nd parameter (JSObject*) of the callback is changed from incumbent global to host defined data

[07:22:09.0405] <arai>
is the JS source code also on disk?

[07:22:22.0694] <davidj361>
Yes

[07:22:46.0028] <arai>
if so, you should compare the time taken by "read the JS code from disk + JS::Evaluate" vs "read the XDR data from disk, decode, instantiate, and execute"

[07:24:10.0516] <arai>
so, `FinalizationRegistryCleanup::QueueCallback` should be updated to follow the change

[07:25:07.0403] <arai>
it can extract the incumbentGlobal from HostDefined, and pass it to the remaining part, so that the remaining part can be updated later

[07:27:13.0318] <arai>
or maybe you're reading and decoding the XDR data every time while you weren't reading the JS code every time but the JS code is cached on memory?

[07:28:02.0102] <arai>
if that's the case, then you can keep JS::Stencil on-memory and use it instead, so that there's no need to read from disk and decode every time

[07:29:55.0144] <sefeng>
arai: ah I see, I could also revert the changes I made in `callHostCleanupFinalizationRegistryCallback`, and then extract incumbentGlobal from `queueFinalizationRegistryForCleanup` 

[07:30:00.0964] <sefeng>
that also works right?

[07:31:24.0628] <arai>
only as temporary state (e.g. Part 1 does that, and Part 2 updates that part)

[07:31:34.0524] <arai>
JS engine shouldn't touch the HostDefined data details

[07:33:16.0633] <arai>
"extracting incumbentGlobal from HostDefined" operation shouldn't be performed inside SpiderMonkey, because the operation is "host-defined" and basically it's supposed to be unknown to SpiderMonkey

[07:33:27.0603] <sefeng>
ah okay, now I get it

[07:33:32.0641] <sefeng>
I'll what you suggested earlier

[07:33:39.0086] <sefeng>
 * I'll do what you suggested earlier, thanks

[07:37:38.0343] <arai>
if the above doesn't make sense, can you provide more details around your setup?   how is the JS code read and executed, how many runtimes or executions are there, and how do you rewrite that part with stencil?

[08:36:45.0926] <Bryan Thrall [:bthrall]>
I need to create a plain object with a single field and value. Is there a faster way to do this than calling `NewPlainObjectWithUniqueNames()`?
I don't want to create the object once and share it, because it's handed off to a script function I don't have control of

[08:37:42.0543] <arai>
Do you create the object frequently?

[08:39:21.0876] <Bryan Thrall [:bthrall]>
Yes. If I pass a null Value instead of creating the object, I see about a 30% performance boost. (This is for [bug 1925128](https://bugzilla.mozilla.org/show_bug.cgi?id=1925128 ))

[08:39:22.0773] <botzilla>
https://bugzil.la/1925128 ‚Äî NEW (bthrall) ‚Äî School Edsby website hangs

[08:40:06.0197] <arai>
if so, a similar technique used for the RegExp match objects could be used, where they share shape

[08:40:31.0267] <arai>
or maybe the iterator result object?

[08:41:29.0811] <arai>
[js::CreateIterResultObject](https://searchfox.org/mozilla-central/rev/ec342a3d481d9ac3324d1041e05eefa6b61392d2/js/src/vm/Iteration.cpp#1325-1350)

[08:42:43.0611] <arai>
with [js::GlobalObject::createIterResultTemplateObject](https://searchfox.org/mozilla-central/rev/ec342a3d481d9ac3324d1041e05eefa6b61392d2/js/src/vm/Iteration.cpp#1380-1414)

[08:43:38.0227] <arai>
so, create a template object with known slot index, and create the object for each case with the template, and directly set the slot value

[08:53:13.0190] <arai>
just to make sure, is the property name always same?  the above technique is for the case where the property is always same, such as, a part of the spec.  if the property name comes from user code, it won't fit much

[08:55:55.0559] <Bryan Thrall [:bthrall]>
Yes, the property name is always the same

[09:01:04.0491] <arai>
okay, then it should work

[09:10:02.0137] <jandem>
in the profile we spend a lot of time tracing `ParseRecordObject`s during GC, also for the micro-benchmark in the bug. One option to fix that is to make these JS objects similar to the parsed objects

[09:10:37.0563] <jandem>
I don't know if there's a nice way to avoid this problem while keeping the rooted hashmaps

[09:13:03.0470] <Bryan Thrall [:bthrall]>
I'm not sure what "make these JS objects similar to the parsed objects" means

[09:14:37.0711] <Bryan Thrall [:bthrall]>
Unfortunately, it looks like `createWithTemplate()` (the iterator result object approach) is not faster than `NewPlainObjectWithUniqueNames()` and may be slightly slower in the micro-benchmark I'm using

[09:14:50.0514] <jandem>
I mean allocate JS objects to hold the keys/values instead of using a GCHashMap

[09:15:40.0353] <Bryan Thrall [:bthrall]>
So you think tracing that will be faster than tracing the GCHashMap?

[09:18:33.0410] <arai>
createWithTemplate being slower is unexpected.  maybe there's something wrong with the setup.  otherwise we should look into iterator code as well

[09:18:53.0334] <jandem>
yes because the gc can trace those more efficiently, for example a minor GC won't need to trace through the full set of objects

[09:22:40.0393] <Bryan Thrall [:bthrall]>
Ok, I'll try using JS Objects instead of GCHashMap

[09:29:02.0018] <Bryan Thrall [:bthrall]>
I'm creating a template object and defining its field with `NativeDefineDataProperty`, then using `createWithTemplate` when I want to create the actual object.

I've attached my patch in case you want to look.

[09:30:37.0875] <Bryan Thrall [:bthrall]>
The microbenchmark is from [jandem's comment here](https://bugzilla.mozilla.org/show_bug.cgi?id=1925128#c7 )

[10:14:40.0163] <sefeng>
arai: when I extract the incumbent global in FinalizationRegistryCleanup::QueueCallback, should I call the `nonCCWGlobal()` in someway?

[13:36:10.0559] <sefeng>
arai: if the result of `incumbentGlobal` from this code 
```
    JS::Value incumbentGlobal = JS::GetReservedSlot(
        callback.mHostDefinedData, mozilla::INCUMENT_SETTING_SLOT);
```
is `Double`, this is wrong right?

[13:45:47.0084] <arai>
hmm, I'm not sure why the nonCCWGlobal call is performed inside SpiderMonkey.  that part seems to be supposed to pass the object that `CycleCollectedJSContext::getIncumbentGlobal` returned

[13:46:28.0308] <arai>
also, even if necessary, [xpc::NativeGlobal](https://searchfox.org/mozilla-central/rev/faa7b1b2a7b509df04a8bafbf8520fc162ad1363/js/xpconnect/wrappers/WrapperFactory.cpp#786) does the same by calling JS::GetNonCCWObjectGlobal

[13:48:46.0779] <arai>
then, the slot is supposed to contain the value set by `CycleCollectedJSContext::getHostDefinedData`, which is object or null

[13:49:03.0160] <arai>
if it returns Double value, it would mean the `mHostDefinedData` contains something else

[13:50:02.0218] <arai>
perhaps mHostDefinedData holds the incumbentGlobal object instead?  then the slot would be a private value, which is Double

[14:53:23.0971] <arai>
Locally, the unpatched case takes 5318 ms, and the patched case takes 6795 ms (+27%).
Then, in the benchmark, vast majority of the time is taken by GCRuntime::minorGC. If I make GCRuntime::minorGC a no-op, the score is reduced to 746 ms vs 691 ms (-7%).
The patch changes the timing of minorGC call. I'm seeing Int32ToStringWithHeap taking much time in minorGC with patched case, compared to unpatched case not hitting minorGC there, and looks like this kind of behavior changes affect the performance.
So, this is not actually the difference between NewPlainObjectWithUniqueNames vs createWithTemplate, but more about the GC scheduling I guess?


[14:55:04.0623] <arai>
it might be nice to look into the allocation part after addressing the GCHaspMap part

[14:57:23.0488] <arai>
Bryan Thrall [:bthrall]: ^

[14:59:25.0289] <Bryan Thrall [:bthrall]>
Thanks for digging into that! Your explanation makes sense to me üôÇ


2024-10-22
[23:41:41.0452] <gkw>
> <@jandem:mozilla.org> gkw: thanks for reporting these exception handling assertion failures. Do you have many of these left? This assertion has been effective for flushing out very old OOM bugs

Thanks for fixing them asap! I think I still do, but I'm super busy these few weeks with non-Mozilla stuff that I can only have time set aside to retest when your patches land on m-c

[23:41:56.0594] <gkw>
In other words, there's more

[23:42:02.0884] <gkw>
jandem: ^^

[23:56:16.0066] <jandem>
gkw: thanks :) Take your time because these shouldn't be urgent, but if you can keep filing them that'd be great

[00:10:50.0658] <l11d>
maybe already well-known but there is a tool called `creduce` for automated minimizing of C programs. it has a `--not-c`, which can also minimize inputs in other languages. I found it rather helpful for minimizing (fuzz)crashes

[00:42:43.0822] <gkw>
l11d: https://github.com/MozillaSecurity/lithium/ is the legendary reducer I've been using for over a decade

[00:43:31.0248] <gkw>
or rather, almost decades

[00:48:03.0304] <l11d>
interesting, I'll definitively give this a try as well

[00:55:39.0342] <gkw>
l11d: It has several interestingness tests. I use the "crashes" and "outputs" ones fairly often. These accept parameters so you can look for specific lines in stdout/stack traces, and they work on Win/Linux/macOS. Best of all, they are written in Python w/tests so you can contribute to them! Disclaimer: I was part of the team that worked on it previously, but Jesse Ruderman was the original creator and now :truber is the main person maintaining it (I think)

[00:56:02.0129] <gkw>
 * l11d: It has several interestingness tests. I use the "crashes" and "output" ones fairly often. These accept parameters so you can look for specific lines in stdout/stack traces, and they work on Win/Linux/macOS. Best of all, they are written in Python w/tests so you can contribute to them! Disclaimer: I was part of the team that worked on it previously, but Jesse Ruderman was the original creator and now :truber is the main person maintaining it (I think)

[00:56:17.0226] <gkw>
 * l11d: It has several interestingness tests. I use the "crashes" and "output" ones fairly often. These accept parameters so you can look for specific lines in stack traces/stdout, and they work on Win/Linux/macOS. Best of all, they are written in Python w/tests so you can contribute to them! Disclaimer: I was part of the team that worked on it previously, but Jesse Ruderman was the original creator and now :truber is the main person maintaining it (I think)

[01:02:57.0221] <l11d>
retrospectively, I should have looked into automated testcase minimization way earlier. spent so much time doing this manually with an outcomes (often) subpar to automatically reduced testcase

[02:12:11.0325] <arai>
oh I overlooked the logic in [js::GetObjectFromIncumbentGlobal](https://searchfox.org/mozilla-central/rev/dfc3050503739883ce6d17e8365bc35410106aba/js/src/vm/JSObject.cpp#1506,1513) and the comment there explains

[02:13:27.0619] <arai>
So, that part is no longer necessary at least in the SpiderMonkey side, as the HostDefined value is regular object

[02:14:12.0288] <arai>
I mean, the `getObjectPrototype` call and `nonCCWGlobal` call  should be removed from SpiderMonkey side

[02:15:56.0204] <arai>
If the Gecko side wants to use different globals for the incumbent global and the hostdefined object for some reason, the wrap/unwrap operation should be performed on the Gecko side

[02:17:20.0923] <arai>
sefeng: ^

[02:57:09.0699] <zhaolikun>
Hello, it seems a file is missing, named 'jit/riscv64/extension/register-riscv.h'. Where should I submit this issue?

[03:00:49.0231] <arai>
Please file a bug in https://bugzilla.mozilla.org/enter_bug.cgi?product=Core&component=JavaScript%20Engine%3A%20JIT

[03:01:27.0941] <Ms2ger>
Reference Bug 1800431

[03:01:29.0364] <botzilla>
https://bugzil.la/1800431 ‚Äî RESOLVED (yahan) ‚Äî riscv64 support in SpiderMonkey - initial patch set

[03:04:01.0018] <zhaolikun>
Thanks~

[09:01:15.0818] <sfink>
jonco: you have a lot more experience in looking at these things, so if there's anything to add to the [GLAM interpolation issue](https://github.com/mozilla/glam/issues/2985), or to correct about what I'm saying, please do.

[09:03:05.0702] <jonco>
sfink: thanks for filing this issue

[09:03:25.0843] <jonco>
That looks fine TBH

[10:00:48.0964] <sfink>
I'm trying to figure out if [the code](https://github.com/mozilla/glam/pull/2995/commits/5d9a2440eec9eddc5dd7bdd44105bc924e82c547) looks right.

[10:25:31.0542] <fkilic>
is this the correct place to ask about js garbage collection in firefox? if so I have a question. Continued in thread ->

[10:25:35.0519] <fkilic>
Let's say that I have a variable X defined in top-level scope (in a sys.mjs file), and X is a large config object. I need to access X only during class initialization (JS window actor), after that X is basically useless. Is X going to be garbage collected automatically after it is used, or will it stay loaded indefinitely just in case another class might be initialized? Would it be more efficient to move variable X to class's constructor?

[10:32:35.0508] <ptomato>
if X is at toplevel scope, it's always reachable, so won't be garbage collected

[10:41:26.0360] <fkilic>
I see, I'll just move it into a function then. Thank you!

[10:57:13.0093] <jonco>
> <@sfink:mozilla.org> I'm trying to figure out if [the code](https://github.com/mozilla/glam/pull/2995/commits/5d9a2440eec9eddc5dd7bdd44105bc924e82c547) looks right.

When I did this, I did a linear interpolation on the bin numbers and then mapped that back to a value in histogram's x domain, which is exponential in the cases I was looking at. The point being that something mid way between two bins is not the same the average of the two bin's values for an exponential histogram. Are there linear histograms? I think so, so this should probably take account of the kind of histogram when interpolating.

[10:57:24.0528] <mccr8>
You could also null out X after you use it.

[10:57:55.0284] <mccr8>
Also keep in mind that if you have function data then closures can keep stuff alive in a weird way.

[11:04:59.0111] <sfink>
I've been looking into this, and I think the code is right even for exponentially growing bucket widths. You're looking for a percentile, say the 90th percentile, and you figure out that it's in a bucket representing the values from 100-1000. It turns out that you're looking at the 34th percentile of that bucket. The distribution *within* the bucket now matters -- if it's uniform within the bucket then you can just estimate 100 + 0.34(1000-100).

[11:06:30.0093] <sfink>
Here's where I get a little shaky: I don't think we have any strong reason to suspect that it's something very different than uniform. Well, sorta: if our full range covers 0ns to 1 year, then we probably should assume that the values thin out towards larger numbers. But that's a different thinning than is created by the exponentially growing bucket sizes.

[11:08:51.0711] <sfink>
but like I said, I'm not confident of this part.

[11:22:51.0005] <jonco>
I'm not sure I'm right either. But I'd note that we're not interpolating on bucket values but on cumulative frequencies of integer labelled bins.

[11:23:28.0331] <jonco>
This is why my original comment recommended talking to data science people - I don't know what the best thing to do here is.

[11:25:26.0762] <sfink>
> <@jonco:mozilla.org> I'm not sure I'm right either. But I'd note that we're not interpolating on bucket values but on cumulative frequencies of integer labelled bins.

wait, is the `.bin` in that code a bucket index, not the min value for the bucket? That would not be right.

[11:26:23.0666] <jonco>
No, I'm assuming that's the value

[11:34:58.0441] <fkilic>
> You could also null out X after you use it.

Thought about it but I really like using `const` just for readability. 

> Also keep in mind that if you have function data then closures can keep stuff alive in a weird way.

Oh I see. I'll keep it in mind. Thank you!

[11:40:43.0454] <sfink>
Oh, then that's ok. To find the 90th percentile, aka the value that 90% of the other values are less than, you find the bucket that contains it based on the cumulative frequencies below each bucket. If 70% of values are less than your target bucket and 5% are greater, then you can map that to the percentile within that bucket completely independently of the distribution: you need the 0.20/(percentage of total values that fall in the bucket=0.25) percentile. How you find that percentile is the tricky part, because it *does* depend on the distribution within the bucket.

[11:41:01.0159] <sfink>
 If it's uniform, it's easy; you can interpolate between the min and max values of the bucket.

[11:41:32.0039] <sfink>
The fact that the next bucket up is twice as wide doesn't change that. (Unless the whole distribution is uniform, but that'd be really weird because it would mean we magically picked the exact right point to end the whole histogrammed value range at rather than it going to zero at the ends.)

[11:42:21.0805] <sfink>
so yes, we're interpolating on cumulative frequencies, but that is just to get to the percentile within the target bucket.

[11:55:38.0765] <sfink>
If you're using `const`, you can still mutate the contents. So instead of `const config = get_configuration(); ...; config = null;` you can do `...; for (const p of Object.getOwnPropertyNames()) { delete config[p]; }`. But obviously that defeats much of the point of using `const` in the first place. A function or IIFE is probably a lot cleaner. Toplevel scope is sticky.

[12:12:14.0745] <sfink>
ah, good. I just saw their comments, and they seem aware of how this works. They'll do the linear thing initially, and potentially add other within-buckets distributions if needed.

[12:17:25.0182] <sfink>
the [trial site](https://dev.glam.nonprod.dataops.mozgcp.net/firefox/probe/gc_mark_ms/explore?) has the interpolation up and it looks pretty good to me!

[13:29:29.0454] <dheitbrink>
 I am looking at a project where we add VS-Code debugger integration with our SM embed, likely via https://microsoft.github.io/debug-adapter-protocol/, has anyone done this before, any advice on where to start? Basically we are a server side app, and we would like our JS devs to able to use VS-Code to connect to our app for a debugging session. 

[13:39:37.0637] <sfink>
I'm guessing you would be the first. I assume that the [devtools Firefox vscode integration](https://github.com/firefox-devtools/vscode-firefox-debug) or the [fork listed at that URL](https://github.com/hbenl/vscode-firefox-debug) would be a good place to start. You'd be replacing the devtools stuff with your own embedding's. The #devtools:mozilla.org room would probably know more or at least be familiar with what would be required. #spidermonkey:mozilla.org devs don't really ever use the Debugger API (well, save for me and gjs people, as far as I know).

[13:49:35.0118] <dheitbrink>
OK thanks I will give this a look.

[16:07:34.0859] <sfink>
I would like to have a range constructor in JS. I have an array of marker start times in the profiler, and I'm computing the deltas between them: `[...Array(53).keys()].map(i => ts[i+1] - ts[i]).map(n => n.toFixed(1))`

[16:08:10.0524] <sfink>
`[...Array(53).keys()]` just doesn't roll off the tongue as well as `range(53)` or whatever.

[16:12:30.0470] <Redfire>
*`[...range(53)]`
`range` should be a generator function

[16:13:43.0608] <sfink>
`range().take(53)` ?

[16:22:24.0109] <cfallin>
Q: pushing to the try server, `mach try`'s push is at "Bundling 379 changesets" and still going (I'm expecting 39 for this stack)... I work in git, my `upstream` is github.com/mozilla/gecko-dev `master` branch; am I forgetting which base to use for try-pushes?

[16:24:53.0643] <sfink>
it does sound like the server doesn't have your base. But you'll need a git user to tell you what base to use. I'm not sure who to ping (though I think the team is like 50/50 right now, though some people are out atm).

[16:26:34.0626] <sfink>
https://firefox-source-docs.mozilla.org/contributing/contribution_quickref.html just says to use what `python3 bootstrap.py --vcs=git` gives you, but I don't know what that is.

[16:26:57.0200] <cfallin>
Cool, I'm doing the cinnabar thing to pull down another base from hg and I'll rebase on that, we'll see if that works better

[16:27:17.0044] <cfallin>
(my actual upstream is BA's repo so I'm unfortunately probably beyond what a "vanilla" bootstrap would give me)


2024-10-23
[01:49:39.0398] <julienw>
> <@sfink:mozilla.org> I would like to have a range constructor in JS. I have an array of marker start times in the profiler, and I'm computing the deltas between them: `[...Array(53).keys()].map(i => ts[i+1] - ts[i]).map(n => n.toFixed(1))`

Array.from({length: 53)}

[01:50:27.0260] <Ms2ger>
That makes them all `undefined`, not `0, 1, 2, ..`

[01:50:57.0156] <julienw>
that's ok, because you can do `.map((_, i) => ...` :-)

[01:51:31.0702] <julienw>
otherwise this works too: Array.from({length: 53)}, (_, i) => o)

[01:51:41.0340] <julienw>
but yeah, not so much better than the other one

[01:51:51.0927] <julienw>
 * otherwise this works too: Array.from({length: 53}, (\_, i) => o)

[01:52:14.0447] <julienw>
 * otherwise this works too: Array.from({length: 53}, (\_, i) => iu)

[01:52:17.0602] <julienw>
 * otherwise this works too: Array.from({length: 53}, (\_, i) => i)

[01:52:22.0747] <evilpie>
Performance wise much better though haha

[01:52:58.0478] <julienw>
performance wise, a for loop would be better :D

[01:52:58.0953] <nicolo-ribaudo>
There is a proposal in TC39 that would help, but it's not been very active lately: https://github.com/tc39/proposal-iterator.range

You'd do `Iterator.range(0, 53).toArray()`

[06:03:11.0105] <@allstarschh>
jon4t4n: hi, I replied a bugzilla comment to you yesterday, https://bugzilla.mozilla.org/show_bug.cgi?id=1858078#c5 , in case you didn't see that (you were already ni?) 

[07:32:23.0132] <dminor>
> <@nicolo-ribaudo:matrix.org> There is a proposal in TC39 that would help, but it's not been very active lately: https://github.com/tc39/proposal-iterator.range
> 
> You'd do `Iterator.range(0, 53).toArray()`

We're planning to have an Outreachy intern look at this proposal starting in December.

[09:02:53.0473] <jon4t4n>
> <@allstarschh:mozilla.org> jon4t4n: hi, I replied a bugzilla comment to you yesterday, https://bugzilla.mozilla.org/show_bug.cgi?id=1858078#c5 , in case you didn't see that (you were already ni?)

Thanks! I'll take a look :)

[12:36:13.0572] <smaug>
sfink: remind me, are functions allocated from nursery, and will a minor GC collect them even if they were temporarily assigned to a JS::Heap?

[12:41:44.0740] <sfink>
The underlying type is nursery-allocatable, but I'm trying to track down whether it is explicitly allocated in the tenured heap.

[12:42:58.0843] <sfink>
I just ran a test in the shell, and yes, they can be allocated in the nursery

[12:43:27.0901] <sfink>
a minor GC will definitely move them, if that's what you need

[12:46:31.0207] <sfink>
if one were in a JS::Heap and then overwritten, I don't think the pre-write barrier would change whether it's reachable. Which direction are you concerned with? It getting collected when you don't want it to, or not getting collected because of barriers or whatever?

[12:48:42.0288] <smaug>
sfink: I was thinking whether minor GC will collect it

[12:49:15.0549] <smaug>
If the JS::Heap was (temporarily) the only thing keeping it alive

[12:51:29.0145] <sfink>
this JS::Heap is not traced?

[12:52:03.0676] <smaug>
It is, but when minor GC runs, JS::Heap would have null value

[12:52:41.0087] <sfink>
then I don't think it will keep it alive. Minor GC reachability depends on roots and the store buffer. Barriers won't keep them alive.

[12:52:52.0722] <smaug>
ok, good, thanks

[12:53:45.0746] <smaug>
Just thinking basically the case when one adds and then almost immediately removes an event listener

[12:54:52.0877] <sfink>
for major GC, I think that would matter. Specifically, if there's an ongoing incremental GC and you do that, then the event listener would not get collected.

[12:55:09.0319] <smaug>
sure, that is fine

[12:58:45.0092] <sfink>
I don't know if there's any weirdness involved with JS reflectors or the holder map that could cause the event listener to be retained. tcampbell might know.

[13:06:09.0902] <tcampbell>
The weird reflectors are DOM objects that are both nsWrapperCache and also call `HoldJSObjects`, but I don't think that applies in this case for the `EventListenerHolder`

[13:09:19.0173] <smaug>
Hmm, what is weird with those? All the wrapper caches need to call holdJSObject when there are expandos

[13:10:03.0122] <smaug>
but yes, CallbackObjects are simpler

[13:12:38.0867] <tcampbell>
wrapper caches calls holdjsobject only if expando added, while if objects with edges to gc directly call holdjsobject in constructor (and then again if expando added). Probably doesn't have much impact on when cleanup happens, since the JSHolderMap::Iter should remove entries the next time the holder is scanned

[13:13:21.0940] <smaug>
oh, you mean extra edges to gc

[13:13:34.0644] <smaug>
yeah, often holdjsobjects is called in the ctor


2024-10-24
[02:06:56.0139] <jonco>
> <@smaug:mozilla.org> Just thinking basically the case when one adds and then almost immediately removes an event listener

Yes, this will not be kept alive by minor GC if it has been removed by the time minor GC runs. Setting a nursery pointer in a Heap<T> will add a store buffer entry to trace it but clearing it will remove that entry again.

[02:08:07.0551] <smaug>
jonco: ok, thanks.  Just trying to figure out yet some more ways to release stuff sooner.

[02:16:03.0834] <smaug>
jonco: also playing again with the idea to run collector's sooner, since right now especially on a fast machine one can create lots of garbage before it gets collected.

[02:22:17.0104] <jonco>
smaug: reducing the max nursery size might also help here

[02:22:29.0938] <jonco>
smaug: also we could experiment with the JSGC_NURSERY_EAGER_COLLECTION_* parameters

[02:23:27.0735] <smaug>
hmm, why would reducing nursery size help in cases like sp3?

[02:24:03.0090] <jonco>
not necessarily for sp3, but it limits the amount of garbage that can be created before it gets collected

[02:25:41.0552] <smaug>
ah, right. Yeah, sp3 is the extreme case here. It is all the time creating tons of garbage, and we do want to avoid minor GCs while it is doing that, if possible.

[02:25:58.0450] <smaug>
 * ah, right. Yeah, sp3 is the extreme case here. It is all the time (when running a subtest) creating tons of garbage, and we do want to avoid minor GCs while it is doing that, if possible.

[03:15:11.0644] <hsivonen>
How should I think of the performance characteristics of AllocateInlineString? https://searchfox.org/mozilla-central/source/js/src/vm/StringType-inl.h#31 Should I think of it having the cost of a malloc or is it closer to a bump allocation on the GC heap? (I'm trying to understand how bad an idea it would be to write code where the happy path does one or two of these but the worst case ends up with lots of these.)

[03:18:07.0333] <hsivonen>
Specifically, I have two options: allocate a new buffer, write everything in the new buffer, which I might have to grow/shrink vs. creating a rope of dependent strings and inline strings. If there are only a couple of things that need to change relative to the input, I'd end up with a rope with few items and almost no copying at the rope creating time. However, if lots of things need to change, it could become a rope of lots of inline strings.

[04:18:38.0534] <jonco>
hsivonen: the latter, it's a single GC cell allocation which will be a bump allocation if it's in the nursery

[07:30:13.0426] <hsivonen>
> <@jonco:mozilla.org> hsivonen: the latter, it's a single GC cell allocation which will be a bump allocation if it's in the nursery

Thanks

[07:36:34.0774] <jjaschke>
There's a bug which is currently in DOM: Core & HTML, which deals with how to [represent numbers in the console](https://bugzilla.mozilla.org/show_bug.cgi?id=1846606). (Maybe foolishly) I marked this one as good-first-bug a while ago, and there is even activity from two contributors. Their investigation showed that the scope of the bug might be too big for a good-first-bug, but they seem to still want to contribute if the bug were split into smaller tasks. I'm happy to help them out and mentor, but I am not experienced enough to say if their approach is the right one, or if they maybe miss something. 

[11:52:05.0819] <jlink>
I'm looking in a crash (MOZ_RELEASE_ASSERT) in the profiler that is ultimately happening because a marker is being set way in the future.

I've tracked it back to the PerformanceMeasureOptions created [here](https://searchfox.org/mozilla-central/source/__GENERATED__/dom/bindings/PerformanceBinding.cpp#1562-1563) with the following (significantly truncated) call stack (full callstack here: https://paste.mozilla.org/o00bgAGS/raw):
> 	mozilla::dom::Performance_Binding::measure(JSContext *, JS::Handle<JSObject *>, void *, const JSJitMethodCallArgs &)	C++
 	mozilla::dom::binding_detail::GenericMethod<mozilla::dom::binding_detail::NormalThisPolicy,mozilla::dom::binding_detail::ThrowExceptions>(JSContext *, unsigned int, JS::Value *)	C++
 	[Inline Frame] CallJSNative(JSContext *, bool(*)(JSContext *, unsigned int, JS::Value *), js::CallReason, const JS::CallArgs &)	C++
 	js::InternalCallOrConstruct(JSContext *, const JS::CallArgs &, js::MaybeConstruct, js::CallReason)	C++
 	js::Interpret(JSContext *, js::RunState &)	C++
 	[Inline Frame] MaybeEnterInterpreterTrampoline(JSContext *, js::RunState &)	C++
 	js::RunScript(JSContext *, js::RunState &)	C++
  	...

but this is now way out of my areas of knowledge and the full call stack is crazy long. I'm _thinking_ that this means that there is some JS code somewhere calling performance.measure() with a bad timestamp but I have no idea where to go from there. Does anyone here know how to make sense of this?

[11:56:24.0520] <jlink>
Also the whole call stack seems long and convoluted to me - a call to HttpChannelChild::OnStopRequest() seems to have triggered a whole lot of stuff to happen.

[12:15:16.0039] <sefeng>
does `DumpJSStack()` give the js call stack?

[12:15:46.0888] <sefeng>
jlink: ^

[12:33:36.0189] <smaug>
Ryan Hunt: curious, have you tried running wasm benchmarks with more TaskController background threads?

[12:35:45.0773] <smaug>
(My guess is that wasm might prefer utilizing as much cpu time as possible, in parallel, but ion might be benefit fewer, but faster cores.)

[12:37:23.0949] <smaug>
 * (My guess is that wasm might prefer utilizing as much cpu time as possible, in parallel, but ion might be benefit fewer,  faster cores.)

[12:44:27.0025] <Ryan Hunt>
> <@smaug:mozilla.org> (My guess is that wasm might prefer utilizing as much cpu time as possible, in parallel, but ion might be benefit fewer,  faster cores.)

I have not tried this. TBH, I‚Äôm out of date with our whole background thread system. Is there a pref or something I could play around with?

[12:46:49.0177] <smaug>
oh, looks like there is an env variable: https://searchfox.org/mozilla-central/rev/18f09bdf36a62ea7079c018301f1d257f71f655b/xpcom/threads/TaskController.cpp#75-93

[14:44:27.0030] <jlink>
> <@sefeng:mozilla.org> jlink: ^

Let me try that now ...

[15:37:32.0622] <mgaudet|out-of-office-until-October-28>
[Neat fuzzing paper](https://dl.acm.org/doi/10.1145/3689736) --  Show an LLM the code for an optimization, then get it to generate a test case which should exercise said optimization. Instrument the opt to provide feedback, then keep asking for more test cases like ones which worked

[15:46:40.0668] <jlink>
[Here](https://paste.mozilla.org/JzRmPpUr/raw) is the call stack that it gave me

[16:06:52.0271] <jlink>
And that has pointed me to:
performance.measure(`${e}-${t}`,{start:performance.timeOrigin,duration:performance.now()})
Which doesn't seem right.


2024-10-25
[17:13:07.0987] <mstange>
I didn't know you could provide your own timestamp to performance.measure!

[05:27:18.0227] <smaug>
jonco: jon4t4n is it expected that https://searchfox.org/mozilla-central/rev/4ac5b1f6cc9d8c186986f52369a2d9a537d10474/js/loader/LoadedScript.cpp#290 ExposeObjectToActiveJS? https://share.firefox.dev/48nz6tV looks quite unexpected

[05:27:33.0785] <smaug>
 * jonco: jon4t4n is it expected that https://searchfox.org/mozilla-central/rev/4ac5b1f6cc9d8c186986f52369a2d9a537d10474/js/loader/LoadedScript.cpp#290 triggers ExposeObjectToActiveJS? https://share.firefox.dev/48nz6tV looks quite unexpected

[05:40:03.0091] <jonco>
smaug: no that is not expected! we don't need to expose for for this predicate

[05:41:05.0893] <jonco>
I'll file a bug

[05:49:11.0282] <jonco>
smaug: filed bug 1927125

[05:49:12.0392] <botzilla>
https://bugzil.la/1927125 ‚Äî NEW (jonco) ‚Äî Ensure we don't trigger gray unmarking when unlinking module scripts

[08:18:08.0299] <mccr8>
Writeup of a Chromium zero day from May. First part is some issue with the hidden class related to moduleImport, and the second part is an escape of the v8 sandbox using the Irregexp VM. https://securelist.com/lazarus-apt-steals-crypto-with-a-tank-game/114282/

[09:37:27.0177] <sfink>
Huh, maybe I should figure out how to buy $1 or so worth of cryptocurrency and leave it lying around on my system, as a honeypot to detect when I've been hacked.

[12:48:12.0555] <debadree25>
when a jit-test is skipped like `// |jit-test| skip-if: !getBuildConfiguration("explicit-resource-management")` how do we identify in the terminal that the tests were indeed skipped because the terminal still shows something like this 
```
[110|  0|  0|  0] 100% ==============================================>|   0.6s
PASSED ALL
```
shouldnt it show the numbers under a different column or something?

[13:48:55.0592] <Bryan Thrall [:bthrall]>
I do think one of those 0s should be the count of skipped tests

[13:55:19.0496] <Bryan Thrall [:bthrall]>
So, the last (gray) column should be skipped tests, but [it looks like it is hardcoded to zero](https://searchfox.org/mozilla-central/source/js/src/tests/lib/jittests.py#769 )

[13:57:47.0929] <debadree25>
ahh! maybe some historic reason? or an oversight!

[14:47:51.0997] <Bryan Thrall [:bthrall]>
https://bugzilla.mozilla.org/show_bug.cgi?id=1927222


2024-10-27
[14:06:44.0790] <log101>
Hi there, I'm doing a research on spider monkey and I have a small question to ask. Seems like there is almost no spider monkey content for the past 3-4 years. There are great videos on FirefoxHacks channel on yt (shout-out to Yulia Startsev) and some blog posts but all dating back 2021 and back. There is a visible inactivity. I just wanted to ask why, are there new priorities for Mozilla, maybe ai etc. What happened 3 years ago?

[14:19:19.0194] <mstange>
log101: The first google result for spidermonkey is spidermonkey.dev which has plenty of recent content

[14:49:07.0122] <log101>
mstange: they are mostly changelogs


2024-10-28
[07:18:08.0376] <mconley>
arai: Hi! Am I right when I suspect that there's no way to unload ESMs like [there is for JSMs](https://searchfox.org/mozilla-central/rev/b655023a1978bcad8cc2fb038b89a058b45e91a7/js/xpconnect/idl/xpccomponents.idl#362-373)? And is there a reason why we wouldn't want to introduce an `unload` for ESMs? I ask, because I'm investigating going down the route of (once again) packaging up the New Tab code as a bundled privileged WebExtension... New Tab makes heavy use of ESMs, and I'm wondering how updating those ESMs at runtime is going to work.

[07:18:21.0672] <mconley>
 * arai: Hi! Am I right when I suspect that there's no way to unload ESMs like [there is for JSMs](https://searchfox.org/mozilla-central/rev/b655023a1978bcad8cc2fb038b89a058b45e91a7/js/xpconnect/idl/xpccomponents.idl#362-373)? And is there a reason why we wouldn't want to introduce an `unload` for ESMs? I ask, because I'm investigating going down the route of (once again) packaging up the New Tab code as a bundled privileged WebExtension... New Tab makes heavy use of ESMs, and I'm wondering how updating those ESMs (basically hotswapping) at runtime is going to work.

[07:19:10.0210] <mconley>
Because this feels like one of the trickier parts of this proposal - runtime upgrade.

[07:19:37.0984] <arai>
yeah, unload is not supported. the reason is that the standard ESM itself has no concept of unload

[07:20:48.0558] <arai>
iiuc, some part of the code emulates upgrade by adding query to the ESM's URL

[07:21:05.0609] <mconley>
Oh that's interesting

[07:21:49.0858] <mconley>
Do you remember where we do that? I'd love to see that.

[07:22:21.0911] <arai>
somewhere around XPI things

[07:22:35.0698] <mconley>
And I guess in that case, we keep the old parsed ESMs in memory until restart?

[07:22:45.0587] <mconley>
 * And I guess in that case, we keep the old parsed ESMs in memory until restart, even though they're no longer going to be used?

[07:23:02.0028] <arai>
yeah, the old one is kept

[07:23:30.0116] <arai>
one of the case I saw was only about automated testing.  so that part doesn't expect long lifetime

[07:24:18.0003] <mconley>
I see, okay

[07:24:41.0988] <mconley>
This I guess?: https://searchfox.org/mozilla-central/rev/b655023a1978bcad8cc2fb038b89a058b45e91a7/services/settings/test/unit/test_remote_settings_release_prefs.js#6

[07:24:42.0205] <arai>
[AddonTestUtils.sys.mjs](https://searchfox.org/mozilla-central/rev/b655023a1978bcad8cc2fb038b89a058b45e91a7/toolkit/mozapps/extensions/internal/AddonTestUtils.sys.mjs#206-233)  this does a kind of "reload"

[07:25:12.0646] <arai>
yeah, that one also looks like doing similar thing

[07:25:34.0977] <mconley>
I guess in this model, I could append some kind of build ID as the suffix

[07:26:22.0985] <arai>
yes, that sounds reasonable

[07:27:00.0696] <mconley>
Okay, thank you!

[07:28:12.0668] <mconley>
willdurand: The mozExtensionHostname doesn't get regenerated each time a WebExtension updates, right?

[07:34:37.0046] <willdurand>
mconley: yes, it's the same uuid as long as the extension is installed

[07:38:20.0761] <mconley>
Okay, thanks!

[10:47:39.0585] <cfallin>
so I lando'd a big PBL patchset and appear to have broken some non-PBL builds because of a missing ifdef (sorry!) -- could someone review this real quick? https://phabricator.services.mozilla.com/D227067

[10:51:42.0016] <mgaudet>
cfallin: stamped

[10:52:39.0144] <cfallin>
thanks very much!

[14:04:03.0579] <smaug>
sfink: do we have ways to do only marking, but now sweeping. Thinking about the CC related marking especially here.

[14:04:10.0910] <smaug>
 * sfink: do we have ways to do only marking, but not sweeping. Thinking about the CC related marking especially here.

[14:07:38.0728] <sfink>
there are some types that don't do anything for sweeping, but that's not what you're talking about. But there's nothing that forces sweeping to have to happen. Mark-only would be straightforward, I think?

[14:16:59.0685] <smaug>
I'm just thinking ways to get the marking bits updated right before CC

[14:36:35.0752] <sfink>
right. When working on the worker gc scheduling, it seemed like it would be nice to drive the decision to compact or not based on how many allocations the GC heap has seen. Similarly, if there hasn't been a lot of JS heap activity, I could definitely see value in doing a mark-only GC for the CC. It'd save less than half the time, but I've seen quite a few situations where we keep doing GCs that don't collect much of anything.

[14:37:34.0317] <sfink>
we don't have a direct signal for garbage creation like refcounting does (the number of decrefs)

[15:20:39.0040] <smaug>
I'm mostly thinking this in context of sp3, which is generating garbage as fast as possible. So there are lots of subtest runs between the start of a GC and start of the next CC

[16:17:24.0444] <sfink>
Oh, interesting. My usual test GCs have sweep time well under 1% of total GC time. On my sp3 run, sweep time is 97% of the total major GC time.

[16:24:35.0185] <sfink>
I mean, we also collect 152MB total over the sp3 run (heap max size is 218MB). So we still want to collect *sometimes*.

[16:32:07.0320] <smaug>
we want to run more often, I think

[16:32:47.0678] <smaug>
 * we want to collect more often, I think

[16:35:14.0022] <sfink>
collect as in, CC or GC? I thought you wanted more CC, less GC

[16:37:41.0078] <smaug>
I want more both, I think, and faster. Or combine them somehow. Run GC marking, then CC, during which CC marks JS garbage with some flag (or does some kind of minor marking) and then sweep GC things

[16:42:08.0427] <sfink>
I'm trying to get my head around "marking JS garbage". We don't really do much with things we know are dead, only with things we know are live.

[16:44:27.0013] <smaug>
yeah, it would need to be something a bit different. Somehow tell to GC that from CC point of view certain GCthings are garbage 

[16:44:30.0263] <sfink>
So GC marking would produce a set of mark bits where the white things are definitely dead, the gray things are maybe dead. CC would mark some gray things white. Then we do a GC sweep to throw out white.

[16:50:54.0752] <smaug>
I guess I could try first some kind of extra marking right before CC

[16:51:26.0263] <smaug>
I should try first just extra sync GC right before the first CC slice. Totally unrealistic, but easy to test

[16:55:24.0327] <sfink>
we have code already for "resetting" an incremental GC. It would probably just be a matter of arranging for `abortSweepAfterCurrentGroup` to be set to true at the beginning of sweeping, and then it'll cancel the whole GC without sweeping. So it might not be too hard to prototype a mark-only GC.


2024-10-29
[17:00:41.0739] <smaug>
ah, that indeed doesn't look too complicated

[17:01:10.0647] <sfink>
I'm worried that some marking might happen during sweeping. We removed most of that. I'm not sure if it's still possible or not.

[17:03:10.0428] <mccr8>
> <@smaug:mozilla.org> yeah, it would need to be something a bit different. Somehow tell to GC that from CC point of view certain GCthings are garbage

We sort of do this already, in CollectWhite.

[17:03:14.0876] <sfink>
[`GCRuntime::markWeakReferences`](https://searchfox.org/mozilla-central/source/js/src/gc/Sweeping.cpp#522) for example does some marking. [`beginMarkingSweepGroup`](https://searchfox.org/mozilla-central/source/js/src/gc/GCRuntime.h#869-870) is ominous.

[17:04:40.0740] <smaug>
> <@mccr8:mozilla.org> We sort of do this already, in CollectWhite.

Right, but that doesn't really tell GC that it can now sweep. We need to still wait for the next gc

[17:05:39.0106] <mccr8>
It would make us depend a lot more on CC correctness than we currently do but maybe that's fine.

[17:06:39.0544] <sfink>
it looks like gray marking happens during what we call sweeping, which is kinda important for the CC. ;-) But maybe there's still a place to cut it off.

[17:09:05.0806] <sfink>
it looks like we'd want to stop after [`endMarkingSweepGroup` and before `beginSweepingSweepGroup`](https://searchfox.org/mozilla-central/rev/73adec8ae1089db082e350da8951b8dde7aa3bcb/js/src/gc/Sweeping.cpp#2362-2384), appropriately enough. But I think we'd need to do that portion for all the sweep groups, which is not how it's currently done. Still, it looks relatively straightforward to make it happen. Whether it would be correct is a whole other question.

[17:44:45.0418] <smaug>
overall memory usage stays quite a bit lower level if GC is caller right before CC.

[17:45:08.0701] <smaug>
(but there is of course quite a bit jank because of non-incremental gc)

[17:57:06.0678] <smaug>
 * overall memory usage stays quite a bit lower level if GC is called right before CC.

[06:55:17.0311] <smaug>
jonco: if I create a JS object during iGC, can the ongoing GC collect it ever (assuming it is not in nursery heap and collected by minorGC)

[06:55:59.0464] <jonco>
no, anything allocated after we start marking will stay alive

[06:56:27.0432] <smaug>
ok, good. That is what I expected üôÇ 

[08:03:37.0513] <jonco>
jandem: Re making all the OrderedHashTable methods static in patch 7 - how necessary is this? It's not great for readability. Is it possible to make the hash table classes derive from JSObject so that you don't need to do this?

[09:04:31.0471] <jandem>
jonco: we used to cast to different types for eg `UnbarrieredTable` and with static methods we're able to avoid that. With inheritance we'd have to bring that back somehow

[09:12:09.0567] <jonco>
Oh right, yes I think you said that. Thanks.

[09:37:18.0663] <jonco>
jandem: Does OrderedHashTableObject need the derived ObjectT or would NativeObject do? It mostly seems to be for slot access.

[09:40:49.0010] <jandem>
jonco: good point, `NativeObject` would probably work. It's a bit less type safe though if you cold pass eg a SetObject to the Map template

[09:41:12.0185] <jandem>
 * jonco: good point, `NativeObject` would probably work. It's a bit less type safe though if you could pass eg a SetObject to the Map template

[09:43:46.0308] <jonco>
Oh right that's true. You do have a type check at the OrderedHashSetObject level though.

[09:46:00.0661] <jandem>
that's true. I can try to change the base class to use NativeObject tomorrow

[09:59:11.0815] <jandem>
at some point it might also be nice to have a shared base class for MapObject and SetObject, that we could then also use there

[10:03:22.0520] <jonco>
yes that would be goo

[10:03:28.0052] <jonco>
 * yes that would be good

[11:46:38.0242] <sefeng>
arai: is there a way to run a paticular js-test? `./mach jit-test --retest Frame-asyncPromise-01.js` runs a lot 

[14:12:06.0020] <arai>
`./mach jit-test Frame-asyncPromise-01.js` should work

[14:22:32.0813] <arai>
jit-test takes substring match for the test path. `--retest FILE` takes a file path to read and write a list of tests

[14:22:54.0274] <sefeng>
thanks! 

[14:22:55.0564] <arai>
anyway, I don't think you need `--retest FILE`

[14:27:51.0546] <sefeng>
arai: I now have a different problem though...I ended up implementing `InternalJobQueue::getHostDefinedData` to make some tests to pass 

[14:28:30.0390] <sefeng>
after that I started to get OOM error for creating the host data object in `InternalJobQueue::getHostDefinedData`

[14:28:50.0126] <sefeng>
I only get this OOM error for certain tests

[14:29:08.0023] <sefeng>
does `InternalJobQueue` have some special requirement..?

[14:29:20.0381] <arai>
what's the test and how does it fail?

[14:30:01.0773] <arai>
some tests are emulating OOM, and I wonder if that's hitting the path

[14:30:37.0203] <sefeng>
[this test](https://searchfox.org/mozilla-central/source/js/src/jit-test/tests/basic/bug1532265.js), crashed at [here](https://searchfox.org/mozilla-central/rev/1235dca15fb62be4357e9e6d78a0d8751ea173b6/js/src/vm/JSContext.cpp#1449)

[14:31:13.0959] <sefeng>
and using rr, the exception was set at https://searchfox.org/mozilla-central/rev/1235dca15fb62be4357e9e6d78a0d8751ea173b6/js/src/vm/JSContext.cpp#297

[14:31:26.0336] <arai>
yeah, the testcase is emulating OOM and testing the error mode

[14:31:59.0183] <arai>
what's the C++ stacktrace ?

[14:32:12.0851] <sefeng>
so what should I do..?

[14:32:46.0260] <sefeng>
oh one sec

[14:32:51.0498] <arai>
pass `--debug --debugger=lldb` (or gdb) to the command, and run it

[14:34:51.0816] <sefeng>
arai: https://paste.mozilla.org/o8e0Ns2U

[14:35:18.0582] <sefeng>
and I just updated the revision with my new changes

[14:35:24.0565] <sefeng>
https://phabricator.services.mozilla.com/D224959

[14:36:23.0946] <arai>
can you also get the stacktrace for the assertion failure?

[14:36:32.0653] <sefeng>
sure, one sec

[14:38:05.0316] <sefeng>
arai: https://paste.mozilla.org/QOvNRexw

[14:44:55.0250] <arai>
So, there's a rule about the error mode and the pending exception.  In most case, the error mode (returning false or nullptr or similar things) should set a pending exception to the JSContext.   And in most case, non-error mode shouldn't have pending exception

[14:45:18.0850] <arai>
`JobQueue::getHostDefinedData` and surrounding handling doesn't follow it

[14:46:48.0833] <arai>
`InternalJobQueue::getHostDefinedData`'s first branch (`if (!cx->compartment())`) returns false without setting pending exception, but the next branch (`if (!objResult)`) return false with pending exception, where the exception is set inside `JS_NewObject`

[14:47:43.0969] <arai>
Then, `js::GetObjectFromHostDefinedData` calls `getHostDefinedData`, and if it fails (returns `false`), it returns `true` without touching pending exception

[14:48:35.0059] <arai>
so, the `if (!cx->compartment())` case works, but the `if (!objResult)` case results in recovering from error mode with pending exception

[14:48:53.0188] <arai>
that's the problem.

[14:50:09.0514] <sefeng>
ok, got it, thanks...should I call getPendingException in `js::GetObjectFromHostDefinedData` ? 

[14:50:13.0496] <sefeng>
to consume it? 

[14:50:17.0498] <arai>
no

[14:50:57.0320] <arai>
Before the patch, `getIncumbentGlobal` had 2 modes, and both are successful mode.  one is that the incumbent global exists, and the other is there's no incumbent global

[14:51:57.0821] <arai>
After the patch, `getHostDefinedData` has 3 modes.  the first one is the hostDefined data exists,  the second one is hostDefined data doesn't exist, and the last one is error mode

[14:52:35.0144] <arai>
the former 2 should return `true` with setting the `data` out parameter to either non-null or null.  the error mode should return `false`

[14:53:09.0093] <arai>
So, the first problem is that `InternalJobQueue::getHostDefinedData`'s first branch is returning `false` without setting exception

[14:53:34.0402] <arai>
if the branch is for the "ostDefined data doesn't exist" case, it should return `true` with setting `data` to null

[14:54:25.0697] <arai>
the second problem is that `js::GetObjectFromHostDefinedData` is converting the error mode to successful mode.  it should keep the error mode, so, the first branch there should just return `false`

[14:59:01.0984] <arai>
added suggestions to the revision

[15:01:20.0141] <sefeng>
thanks! does `data.set(nullptr);` set an exception?

[15:01:26.0033] <arai>
no

[15:01:48.0898] <arai>
it just sets the mutable handle to null

[15:02:56.0367] <sefeng>
oh okay, we return true now

[15:04:08.0566] <arai>
in most case, function that takes `JSContext*` as the first parameter sets an exception on error mode (when returning `false` or `nullptr`)

[15:05:33.0395] <sefeng>
ok! thanks 


2024-10-30
[17:11:57.0210] <sfink>
> <@sfink:mozilla.org> Oh, interesting. My usual test GCs have sweep time well under 1% of total GC time. On my sp3 run, sweep time is 97% of the total major GC time.

smaug: oops, I looked at this again. That sweep time includes the time spend marking during the sweep phase. If I separate that out, then it's only 9% of time spent sweeping, 91% marking (including marking time during both mark and sweep phases). So it looks like a mark-only GC wouldn't buy us all that much.

[17:12:16.0010] <sfink>
I'm using [this profile](https://share.firefox.dev/4hsl2mM) from my laptop.

[03:16:47.0517] <smaug>
sfink: yeah, I started to see something similar. The garbage we have in this case is mostly full window+document, and several of them. So quite a bit marking for CC

[06:59:42.0739] <sefeng>
arai: now all test failures are fixed, I have a warning needs to be fixed `missing field 'spec' initializer`, is it [this](https://searchfox.org/mozilla-central/source/toolkit/components/finalizationwitness/FinalizationWitnessService.cpp#161-162)?

[07:01:18.0892] <arai>
where's the warning shown?

[07:02:31.0460] <sefeng>
`/builds/worker/workspace/obj-build/dist/include/jsapi.h:115:22: error: missing field 'spec' initializer`, that's the last line of my changes in `jsapi.h`

[07:03:02.0166] <sefeng>
https://paste.mozilla.org/7qa11xGX

[07:05:22.0553] <arai>
I suppose, the definition should be put inside cpp file

[07:05:40.0973] <arai>
both sHostDefinedData and sHostDefinedDataClass

[07:06:24.0579] <arai>
otherwise, omitting the field initializers should be fine

[07:06:43.0543] <arai>
err, maybe I'm missing something

[07:07:40.0022] <sefeng>
I can definitely try to move those around..do you have a suggestion about where I should put them? I've been questioning myself about putting them in `jsapi.h`...

[07:09:15.0575] <arai>
I'm not sure I follow the intent.  looks like it's shared between the internal queue and gecko

[07:09:26.0114] <arai>
basically they don't have to share the definition

[07:10:49.0028] <sefeng>
arai: so for both `InternalJobQueue::getHostDefinedData` and `CycleCollectedJSContext::getHostDefinedData` create it 

[07:11:10.0880] <sefeng>
so I am sharing the definition between JS and the embedding

[07:11:15.0579] <sefeng>
is it..not correct?

[07:11:17.0863] <arai>
InternalJobQueue doesn't actually have to return any object, given it doesn't use the passed value in `InternalJobQueue::enqueuePromiseJob`

[07:12:38.0135] <arai>
it's "host-defined", and it's completely opaque to SpiderMonkey, right?  if so, the values returned by `getHostDefinedData` doesn't have to use any specific class, but the embedding can define its own class

[07:13:16.0932] <arai>
so, even if the InternalJobQueue need to return some value as HostDefined data, it can be different class than Gecko's one

[07:14:42.0521] <sefeng>
hmm, I though `JS_NewObject` needs to know the definition, but sounds like it doesn't have to?

[07:16:10.0819] <arai>
`JS_NewObject` takes `JSClass`, yes, but it's only because the consumer wants to use the class

[07:16:31.0465] <arai>
the InternalJobQueue case doesn't need to use the class

[07:17:09.0001] <sefeng>
er..but it sets the incumbent global to the slot?

[07:17:26.0860] <arai>
but the slot value is unused and just thrown away

[07:17:53.0258] <arai>
the `InternalJobQueue::enqueuePromiseJob` method doesn't touch the `hostDefinedData` parameter

[07:17:59.0624] <sefeng>
oh I see....

[07:18:54.0839] <arai>
so, with the unpatched code, the internal job queue has "incumbentGlobal" things only because that was a part of interface

[07:19:12.0531] <arai>
but now that's not longer a part of interface and it's hidden behind "HostDefined" data

[07:21:44.0976] <arai>
So, the all those definition of the HostDefined data inside jsapi.h should be moved to Gecko side, possibly in `CycleCollectedJSContext.{cpp,h}` or `WebTaskScheduler.{cpp,h}`

[07:21:58.0152] <sefeng>
okay! I think the caller does a null check or something so I implemented it this way..let me check if I did some mistakes in the caller 

[07:26:10.0341] <arai>
Then, I should've clarified.  That path is going to add one more allocation to the job handling, that is the `JS_NewObject` call inside `CycleCollectedJSContext::getHostDefinedData`. Once the patch starts working, we'll need to look into the performance impact, and if that affects too much, we'll need to look into different design, or apply a kind of cache or something

[07:26:34.0185] <arai>
(not yet sure how critical the JS_NewObject is tho)

[08:29:43.0118] <sefeng>
arai: so `FinalizationQueueObject::create` calls `js::GetObjectFromHostDefinedData` and then `InternalJobQueue::getHostDefinedData`, so the caller actually uses it?

[08:30:11.0972] <sefeng>
[this is how it's used today](https://searchfox.org/mozilla-central/rev/5fdbe0d78d61581aa4b37ce82bbf31c2bd7826f1/js/src/builtin/FinalizationRegistryObject.cpp#692,703)

[08:34:54.0665] <arai>
The value is [stored](https://searchfox.org/mozilla-central/rev/5fdbe0d78d61581aa4b37ce82bbf31c2bd7826f1/js/src/builtin/FinalizationRegistryObject.cpp#692,703) into `IncumbentObjectSlot` slot of the FinalizationQueueObject`

And the slot value is get by [FinalizationQueueObject::incumbentObject](https://searchfox.org/mozilla-central/rev/5fdbe0d78d61581aa4b37ce82bbf31c2bd7826f1/js/src/builtin/FinalizationRegistryObject.cpp#757-758)

That incumbentObject object is [passed to callHostCleanupFinalizationRegistryCallback](https://searchfox.org/mozilla-central/rev/5fdbe0d78d61581aa4b37ce82bbf31c2bd7826f1/js/src/gc/FinalizationObservers.cpp#305,309-310)

and then [passed to the callback function specified by the embedding](https://searchfox.org/mozilla-central/rev/5fdbe0d78d61581aa4b37ce82bbf31c2bd7826f1/js/src/gc/GC.cpp#1649-1650,1654)
that callback is set by [JS::SetHostCleanupFinalizationRegistryCallback](https://searchfox.org/mozilla-central/rev/5fdbe0d78d61581aa4b37ce82bbf31c2bd7826f1/js/public/GCAPI.h#1344) API, which is called in [mozilla::FinalizationRegistryCleanup::Init](https://searchfox.org/mozilla-central/rev/5fdbe0d78d61581aa4b37ce82bbf31c2bd7826f1/xpcom/base/CycleCollectedJSContext.cpp#890) and the callback is [mozilla::FinalizationRegistryCleanup::QueueCallback](https://searchfox.org/mozilla-central/rev/5fdbe0d78d61581aa4b37ce82bbf31c2bd7826f1/xpcom/base/CycleCollectedJSContext.cpp#894)


[08:35:15.0169] <arai>
So, SpiderMonkey actually doesn't touch the object (except for wrap/unwrap)

[08:37:03.0949] <sefeng>
arai: but don't I still need to create the hostDefined object in Spidermonky to pass it around? so the definition of it is still needed there?

[08:37:43.0492] <arai>
where do you need to create it?

[08:38:16.0777] <sefeng>
arai: In InternalJobQueue::getHostDefinedData?

[08:39:10.0974] <arai>
InternalJobQueue doesn't need HostDefined data.  and even if it needs, the definition isn't necessarily be same as Gecko

[08:40:12.0914] <sefeng>
okay, why doesn't it need it?

[08:42:00.0624] <arai>
[[HostDefined]] data is not part of ECMAScript.  the each field comes from the HTML spec ( https://html.spec.whatwg.org/#hostmakejobcallback )

[08:42:58.0586] <arai>
InternalJobQueue doesn't implement any of those HTML spec things, and it doesn't touch [[HostDefined]] data

[08:44:49.0338] <sefeng>
arai: er..okay...that makes sense, so I shouldn't implement `InternalJobQueue::getHostDefinedData` at all? and keep getIncumbentGlobal?

[08:45:21.0212] <arai>
you need getHostDefinedData, given it's replacing the getIncumbentGlobal method

[08:45:28.0492] <arai>
but getHostDefinedData can just return a nullptr

[08:46:05.0493] <arai>
And all remaining part inside SpiderMonkey will pass the nullptr around

[08:47:43.0757] <arai>
the nullptr will eventually be passed back to InternalJobQueue, especially InternalJobQueue::enqueuePromiseJob method. and the method doesn't use the parameter

[08:48:26.0096] <arai>
the nullptr is also eventually passed to the shell's FinalizationRegistryCallback function  [ShellCleanupFinalizationRegistryCallback](https://searchfox.org/mozilla-central/rev/5fdbe0d78d61581aa4b37ce82bbf31c2bd7826f1/js/src/shell/js.cpp#1336), but it doesn't also use the parameter

[08:49:19.0843] <sefeng>
so `FinalizationQueueObject::create` needs to check if JobQueue, and allow it to be null if it's an InternalJobQueue?

[08:49:26.0169] <sefeng>
 * so `FinalizationQueueObject::create` needs to check the JobQueue, and allow it to be null if it's an InternalJobQueue?

[08:50:35.0631] <arai>
`FinalizationQueueObject::create` is also going to use HostDefined object instead of Incumbent Global

[08:50:53.0541] <arai>
and HostDefined object can always be nullptr, regardless of the JobQueue's implementation

[08:52:39.0289] <arai>
(actually, even in the current code, it should accept incumbentObject being nullptr, and handle nullptr case in the remaining code path)

[08:53:50.0037] <arai>
(that case doesn't happen in practice, but there's not much reason to prohibit it)

[08:54:36.0843] <arai>
Anyway, the current non-null requirement shouldn't be kept if those parts are rewritten with HostDefined object

[08:55:53.0684] <sefeng>
okay, thanks....so if `Rooted<JSObject*> hostDefinedData(cx)` is null, do I still set the slot?

[08:56:24.0563] <arai>
FinalizationQueueObjec's slot?

[08:56:39.0516] <arai>
If so, yes, you can use JS::ObjectOrNullValue

[08:56:41.0103] <sefeng>
(I think I sortof finally get this, I didn't figure out host defined object can be null)

[08:56:43.0532] <sefeng>
yeah

[08:57:18.0145] <arai>
and use JS::Value::toObjectOrNull when extracting from the slot

[08:57:43.0173] <sefeng>
okay! thanks 

[09:18:19.0699] <smaug>
jonco: yulia you may have some opinion on https://github.com/whatwg/html/pull/10528 (that seems to be in tomorrow's WHATNOT agenda)

[09:36:48.0122] <Ms2ger>
What's the deal with `./mach try` going through lando?

[09:39:59.0463] <jandem>
Ms2ger: they changed the default in bug 1923647, but you can still `--push-to-vcs` too. Pushing to try through lando is a lot faster though

[09:43:18.0700] <Ms2ger>
Oh, this seems to just be to avoid me waiting on the lock locally? Seems like a lot of effort, but ok

[09:44:19.0754] <jandem>
it also uses SSO instead of SSH for authentication

[09:45:01.0431] <Ms2ger>
[old man shakes fist at SSO]

[13:10:58.0739] <sefeng>
arai: I now have an crash about value not in the same compartment at the `JS_SetReservedSlot` call in `CycleCollectedJSContext::getHostDefinedData`, should I wrap the global here?

[13:11:08.0313] <sefeng>
not sure how to do it properly in DOM code

[13:14:58.0460] <sefeng>
oh maybe I should do it in JSRuntime::getHostDefinedData

[13:15:40.0149] <sefeng>
err, maybe not, that means we are creating the object in the JS engine..

[14:02:55.0067] <arai>
you'll need to enter the global's realm and create object there

[14:04:09.0528] <arai>
https://searchfox.org/mozilla-central/source/js/public/Realm.h#193

[14:31:40.0210] <smaug>
sfink: what does mark_weak mean?

[14:31:45.0043] <smaug>
Weakreferences?

[14:32:55.0394] <smaug>
(in sp3 logs there are quite a few weak references.)

[14:36:35.0231] <sfink>
I hadn't started looking into that yet. I think it includes a couple of different things. Looking...

[14:39:27.0221] <sfink>
(some of) WeakMap marking and jitcode marking are the two things I see.

[14:39:35.0941] <sfink>
uh oh, the latter might be an artifact of profiling, it looks like?

[14:40:04.0933] <sfink>
I'll look at the profile to see if I can tell what's taking the time

[14:42:06.0667] <sfink>
oh, and something I meant to mention but forgot, there's pretty much always a COMPARTMENT_REVIVED GC after every GC.

[14:42:07.0776] <smaug>
oh, perhaps we need profiles without any js stuff?

[14:42:50.0256] <smaug>
COMPARTMENT_REVIVED is really bad yes. I don't see that often and I have a patch to make the triggered CC incremental 

[14:43:27.0694] <smaug>
but perhaps it is just heuristics which need to change for COMPARTMENT_REVIVED

[14:44:34.0524] <sfink>
for the slice I'm looking at, it's 2/3 jitcode

[14:45:44.0163] <smaug>
I wonder if profiler is doing that, or is it just that sp3 creates tons of jit code (because we don't reuse )

[14:47:01.0427] <sfink>
the [comment](https://searchfox.org/mozilla-central/rev/53e8dfd81c32f1ab275516406ec06a68136aaef0/js/src/jit/JitcodeMap.cpp#279-300) seems to imply profiler-related stuff

[14:47:32.0653] <sfink>
though I notice it [disables sampling](https://searchfox.org/mozilla-central/rev/53e8dfd81c32f1ab275516406ec06a68136aaef0/js/src/jit/JitcodeMap.cpp#304). I'm not sure how it can get so many samples, then??!

[14:47:42.0814] <smaug>
There was https://phabricator.services.mozilla.com/D195575 for COMPARTMENT_REVIVED

[14:50:41.0524] <smaug>
julienw: is it enough to disable js in the profiler's settings to avoid that stuff sfink linked ?

[14:52:15.0925] <sfink>
er, actually, I'm not seeing JitcodeGlobalTable::markIteratively in the stack. I tihnk I might have gone on the wrong path here.

[14:54:18.0063] <smaug>
Do we allocate jit code from the nursery heap ?

[14:54:34.0266] <sfink>
oh, hm, maybe that's because most of the time is in `processMarkStackTop`

[14:55:00.0712] <sfink>
> <@smaug:mozilla.org> Do we allocate jit code from the nursery heap ?

no

[14:55:59.0797] <sfink>
 * oh, hm, maybe that's because most of the time is in `markUntilBudgetExhausted`

[14:57:52.0515] <sfink>
ok, it looks like 1/4 of the mark_weak time is in MarkJitcodeGlobalTableIteratively (which seems profiler-related), 1/6 in enterWeakMarkingMode (so WeakMap stuff), and the rest in looping through the mark stack presumably resulting from those first two.

[15:00:02.0176] <sfink>
(in this randomly chosen slice; I probably out to zoom out)

[15:00:14.0716] <sfink>
I have to run for a bit, though

[15:02:22.0141] <sfink>
oh, if I aggregate across all calls to markWeakReferences (the thing labeled mark_weak), it's only 2.8% MarkJitcodeGlobalTableIteratively; all the time is in markUntilBudgetExhausted)

[15:03:59.0529] <smaug>
I don't see real difference whether to profile with js on or off

[16:17:34.0285] <sfink>
Quite a bit of time in `markImplicitEdges`, mostly in doing lookups. I could try digging up my patch for speeding that up. I abandoned it originally because it didn't seem to make a difference.

[16:18:10.0546] <sfink>
but back then, I never saw much time spent in this stuff in the first place, so it made sense that it wouldn't matter.


2024-10-31
[18:32:10.0772] <dragonslayer>
can any one help me with this test sample code i made


So i keep getting a heap error with this code and cant understand why its doing that i know somethings need there own memory but any help with this test sample would benefit me alot .
```
#define DEBUG
#include <jsapi.h>
#include <iostream>
#include <string>
#include <js/Initialization.h>
#include <js/Object.h>
#include <js/Warnings.h>
#include <js/CompilationAndEvaluation.h>
#include <js/SourceText.h>

#include "js/CharacterEncoding.h"
#include "js/Conversions.h"

inline JSClass global_class = { "global", JSCLASS_GLOBAL_FLAGS, &JS::DefaultGlobalClassOps };

class SpiderMonkeyEngine {
public:
  SpiderMonkeyEngine() {
    if (!JS_Init()) { throw std::runtime_error("Failed to initialize JS engine"); }

    cx = JS_NewContext(8192 * 1024); // 8MB stack
    if (!cx) { throw std::runtime_error("Failed to create JS context"); }

    JS::InitSelfHostedCode(cx);

    JS::RealmOptions options;
    auto newGlobal = JS_NewGlobalObject(cx, &global_class, nullptr, JS::FireOnNewGlobalHook, options);
    if (!newGlobal) { throw std::runtime_error("Failed to create global object"); }

    global.init(cx, newGlobal);

    JSAutoRealm ar(cx, global);

    const char* script = "function hello(name) { return 'Hello, ' + name; }";
    JS::CompileOptions opts(cx);
    JS::SourceText<mozilla::Utf8Unit> srcBuf;
    if (!srcBuf.init(cx, script, strlen(script), JS::SourceOwnership::Borrowed)) { throw std::runtime_error("Failed to initialize source buffer"); }

    JS::RootedValue val(cx);
    JS::MutableHandleValue rval(&val);

    if (!JS::Evaluate(cx, opts, srcBuf, rval)) { throw std::runtime_error("Failed to compile script"); }
  }

  ~SpiderMonkeyEngine() {
    JS_DestroyContext(cx);
    JS_ShutDown();
  }

  std::string callHello(const std::string& name) {
    JSAutoRealm ar(cx, global);

    JS::RootedString jsStr(cx, JS_NewStringCopyZ(cx, name.c_str()));
    if (!jsStr) { throw std::runtime_error("Failed to create JS string"); }

    JS::RootedValue func(cx);
    if (!JS_GetProperty(cx, global, "hello", &func) || !func.isObject() || !JS_ObjectIsFunction(&func.toObject())) {
      throw std::runtime_error("Failed to get hello function");
    }

    JS::RootedValueArray<1> args(cx);
    args[0].setString(jsStr);

    JS::RootedValue val(cx);
    JS::MutableHandleValue rval(&val);

    if (!JS_CallFunctionValue(cx, global, func, args, rval)) { throw std::runtime_error("Failed to call hello function"); }

    if (!rval.isString()) { throw std::runtime_error("Failed to get string back"); }
    //JS::RootedString resultStr(cx, rval.toString());
    JS::RootedString resultStr(cx, JS::ToString(cx, rval));
    /// UNCOMMENT THE NEXT LINE TO TRIGGER THE CRASH ON ROUTINE EXIT
    JS::UniqueChars resultCStr = JS_EncodeStringToUTF8(cx, resultStr);
    /// UNCOMMENT THE ABOVE LINE TO TRIGGER THE CRASH ON ROUTINE EXIT
    if (!resultCStr) {
      throw std::runtime_error("Failed to encode result string");
    }
    //
    std::string resultCppStr(resultCStr.get());
    return resultCppStr;
  }

protected:
  JSContext* cx;
  JS::PersistentRootedObject global;
};

int main() {
  try {
    SpiderMonkeyEngine engine;
    std::string result = engine.callHello("World");
    std::cout << result << std::endl;
  }
  catch (const std::exception& e) {
    std::cerr << e.what() << std::endl;
    return 1;
  }

  return 0;
}
```

[19:33:17.0482] <arai>
what's the details of the "heap error" ?  for example, you can run the program with debugger to see the stack trace and some other details.  also, if you're not using a debug build of SpiderMonkey, try using a debug build (--enable-debug), that enables debug assertions and it can catch something 

[19:34:41.0594] <arai>
also, we don't support the C++ "throw".  so it might break something 

[19:46:23.0309] <sfink>
there should be a null check on the result of `JS::ToString` (`if (resultStr == nullptr)` would work), but the commented out `rval.toString()` should also work since you've already tested `isString()`.

[19:47:49.0335] <sfink>
I *think* throwing exceptions should be ok, as long as it never unwinds a JSAPI stack frame. But I don't know for sure; it could be that you have to compile with `-fno-exceptions` for anything to work.

[19:48:50.0145] <sfink>
I would expect what you have for the `MutableHandleValue` should work, but normally you wouldn't use the `rval` temporary. Just pass `&val` into `JS_CallFunctionValue` directly.

[19:49:05.0304] <sfink>
 * I would expect what you have for the `MutableHandleValue` to work, but normally you wouldn't use the `rval` temporary. Just pass `&val` into `JS_CallFunctionValue` directly.

[20:23:54.0511] <arai>
the other option is to wrap the value on Gecko side with [JS_WrapValue](https://searchfox.org/mozilla-central/rev/53e8dfd81c32f1ab275516406ec06a68136aaef0/js/src/jsapi.h#156) or [JS_WrapObject](https://searchfox.org/mozilla-central/rev/53e8dfd81c32f1ab275516406ec06a68136aaef0/js/src/jsapi.h#153-154)

[20:25:21.0963] <arai>
 * the other option is to wrap the slot value on Gecko side with [JS\_WrapValue](https://searchfox.org/mozilla-central/rev/53e8dfd81c32f1ab275516406ec06a68136aaef0/js/src/jsapi.h#156) or [JS\_WrapObject](https://searchfox.org/mozilla-central/rev/53e8dfd81c32f1ab275516406ec06a68136aaef0/js/src/jsapi.h#153-154)

[20:25:32.0235] <arai>
the SpiderMonkey side has wrap/unwrap for the passed HostDefined object, so the Gecko side can pass an object from any compartment

[20:27:16.0331] <arai>
the requirement here is that the object and its slot values should come from the same compartment.  the `JSAutoRealm` way makes the HostDefined object belongs to the global's compartment.   The JS_WrapValue way wraps the global object and set the CCW to the HostDefined object's slot

[20:28:32.0240] <arai>
JSAutoRealm way can be easier, given that you don't have to unwrap the slot value when accessing it

[02:32:00.0398] <jonco>
> <@smaug:mozilla.org> jonco: yulia you may have some opinion on https://github.com/whatwg/html/pull/10528 (that seems to be in tomorrow's WHATNOT agenda)

I was on PTO yesterday but I've looked at this this morning. The mechanics of the change look fine. I don't love that import map conflicts are ignored with only a warning but at least there is a warning now.

[03:07:09.0877] <canova>
Yes, this code will not run if you disable the js feature in about:profiling

[03:27:13.0866] <smaug>
jandem: jonco is jit code somehow bound to a global or zone, or what keeps it alive?

[03:27:23.0740] <smaug>
(I've probably asked this before üôÇ )

[03:29:04.0160] <jandem>
if a JS function or script is alive we keep its JIT code alive, but we can discard JIT code on GC before the function dies based on some heuristics

[03:30:25.0305] <jandem>
 * if a JS function or script is alive we keep its JIT code alive, but we can also discard all JIT code in a Zone on GC based on some heuristics

[03:30:52.0214] <smaug>
we can't for example discard if the relevant global/realm is dying?

[03:31:47.0997] <smaug>
Also, did we have some statistic of how much jit code is in memory?

[03:34:04.0941] <jandem>
the global dying in the sense of it's not actually collected by the GC yet but the browser knows it's navigated away from? we talked about that before also for canceling off-thread Ion compilations. I have a local patch stack somewhere that makes JIT code discarding more of a per-realm thing instead of per-zone, that would help here

[03:36:55.0814] <smaug>
right, that thing. sp3, on this laptop, ends up creating and "destroying" 20 realms (used for subtests) between major GCs

[03:38:01.0027] <jandem>
I'm not sure if we can discard its JIT code right away but we could at least cancel off-thread compilations at that point and be more aggressive about discarding JIT code for such realms

[03:38:50.0574] <jandem>
 * I'm not sure if we can discard the JIT code for such realms right away but we could at least cancel off-thread compilations at that point and be more aggressive about discarding JIT code for such realms

[03:39:48.0432] <smaug>
what is blocking us discarding, say when minorGC runs?

[03:42:03.0914] <jandem>
discarding JIT code can be slow and we want minor GCs to be fast. We could add a "mark realm as dying" JSAPI and use that to cancel compilations and discard JIT code for that realm

[03:43:32.0582] <jandem>
one issue with that still is that there may be other realms that point to the dying one and that can include JIT guards

[03:43:38.0221] <smaug>
What if we found idle time after realm is likely dying (if course one can always access the content of an iframe even after removing it from the document, if one had reference) and tried to discard then?

[03:43:54.0040] <smaug>
aha

[03:44:00.0450] <smaug>
What does a JIT guard mean?

[03:46:31.0109] <jandem>
JIT ICs can for example have a pointer to a shape (which keeps its realm alive) that it uses for a shape guard. Baseline ICs use weak pointers for shapes and some other things now but we don't do that in Ion ICs yet IIRC

[03:49:07.0582] <jandem>
purging JIT code earlier for dying realms is probably a good idea but I don't know how much it will help. Maybe the gc can collect more garbage that way but I'm not sure

[03:50:01.0367] <jandem>
 * purging JIT code earlier for dying realms is probably a good idea but I don't know how much it will help. Maybe the gc can collect more garbage that way and will be a bit faster, but hard to say how much

[08:02:29.0017] <tjr>
Hey folks, if anyone could weigh in on this odd x86/x64 arch fingerprinting leak we would appreciate it! https://bugzilla.mozilla.org/show_bug.cgi?id=1928095

[08:23:46.0830] <mgaudet>
tjr: This comment suggests this might be known and expected: https://searchfox.org/mozilla-central/source/js/public/Value.h#425-432 

[08:24:30.0829] <iain>
Writing up a comment. I think the key part of the JS spec is [here](https://tc39.es/ecma262/#sec-numerictorawbytes)

[08:28:28.0236] <jandem>
oh I also commented on the bug

[13:45:51.0000] <mgaudet>
Hmm. somehow `1.02 ¬± 0.02 times faster` for this patch feels underwhelming. 

[15:10:24.0968] <iain>
mgaudet: It's probably not slower!

