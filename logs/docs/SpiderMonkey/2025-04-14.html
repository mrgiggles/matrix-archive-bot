<!DOCTYPE html><html><head>
  <meta charset="UTF-8">
  <title>SpiderMonkey on 2025-04-14</title>
  <link rel="stylesheet" href="../style.css">
  <script>window.room = "SpiderMonkey";</script><script src="../render-roomlist.js"></script>
  <script src="../logs.js"></script>
</head>
<body><div class="wrapper">
<div class="sidebar">
<div class="title">SpiderMonkey<br>2025-04-14<br><a href="plaintext/">plaintext logs</a></div>
<div class="nav">
<a href="2025-04-11" class="nav-link"><span>prev</span></a>
<a href="2025-04-15" class="nav-link"><span style="float:right">next</span></a>
</div>
    <div class="all-rooms"><noscript>JavaScript is required to load the channel index, but you can go to <a href="../..">the static index</a> directly.</noscript></div>
<div class="footer"><a href="https://github.com/bakkot/matrix-archive-bot">source on github</a></div>
</div>
<div class="rhs">
<div class="rhs-header">
<span id="error" style="color: red; display:none">error</span>

<input type="text" id="query" size="25" placeholder="Search SpiderMonkey">
<a id="search-submit" class="button icon-link" title="Search">
  <svg class="icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><path d="M505 442.7L405.3 343c-4.5-4.5-10.6-7-17-7H372c27.6-35.3 44-79.7 44-128C416 93.1 322.9 0 208 0S0 93.1 0 208s93.1 208 208 208c48.3 0 92.7-16.4 128-44v16.3c0 6.4 2.5 12.5 7 17l99.7 99.7c9.4 9.4 24.6 9.4 33.9 0l28.3-28.3c9.4-9.4 9.4-24.6.1-34zM208 336c-70.7 0-128-57.2-128-128 0-70.7 57.2-128 128-128 70.7 0 128 57.2 128 128 0 70.7-57.2 128-128 128z"></path></svg>
</a>
</div>

<div class="log"><table id="log-table"><tbody id="log-tbody">

  <tr class="msg" id="L0"><td class="ts-cell"><a class="ts" href="#L0" alt="Mon Apr 14 2025 03:32:38 GMT-0700 (Pacific Daylight Time)">10:32</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@smaug:mozilla.org">smaug</span>&gt;</div></td><td class="msg-cell"><span class="nick-4">jonco</span>: FWIW, I have some patches to make PromiseJob* stuff not js holders at all</td></tr>
  <tr class="msg" id="L1"><td class="ts-cell"><a class="ts" href="#L1" alt="Mon Apr 14 2025 03:33:05 GMT-0700 (Pacific Daylight Time)">10:33</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@smaug:mozilla.org">smaug</span>&gt;</div></td><td class="msg-cell">Since they are already in the microtask queue, we can just trace the whole queue, and trace black even</td></tr>
  <tr class="msg" id="L2"><td class="ts-cell"><a class="ts" href="#L2" alt="Mon Apr 14 2025 03:43:45 GMT-0700 (Pacific Daylight Time)">10:43</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@jonco:mozilla.org">jonco</span>&gt;</div></td><td class="msg-cell"><span class="nick-4">smaug</span>: Yes! That would be better.</td></tr>
  <tr class="msg" id="L3"><td class="ts-cell"><a class="ts" href="#L3" alt="Mon Apr 14 2025 03:44:41 GMT-0700 (Pacific Daylight Time)">10:44</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@smaug:mozilla.org">smaug</span>&gt;</div></td><td class="msg-cell"><span class="nick-4">jonco</span>: and I'm also reusing the job object, since that is effective often with promise chains</td></tr>
  <tr class="msg" id="L4"><td class="ts-cell"><a class="ts" href="#L4" alt="Mon Apr 14 2025 03:45:36 GMT-0700 (Pacific Daylight Time)">10:45</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@smaug:mozilla.org">smaug</span>&gt;</div></td><td class="msg-cell">It is enough to keep one object alive for recycling, that helps quite a bit in many cases</td></tr>
  <tr class="msg" id="L5"><td class="ts-cell"><a class="ts" href="#L5" alt="Mon Apr 14 2025 03:46:06 GMT-0700 (Pacific Daylight Time)">10:46</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@jonco:mozilla.org">jonco</span>&gt;</div></td><td class="msg-cell">OK, nice.</td></tr>
  <tr class="msg" id="L6"><td class="ts-cell"><a class="ts" href="#L6" alt="Mon Apr 14 2025 03:46:35 GMT-0700 (Pacific Daylight Time)">10:46</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@jonco:mozilla.org">jonco</span>&gt;</div></td><td class="msg-cell">I guess you saw the bug about optimizing the host defined object stuff? (Can't find the number right now)</td></tr>
  <tr class="msg" id="L7"><td class="ts-cell"><a class="ts" href="#L7" alt="Mon Apr 14 2025 03:47:45 GMT-0700 (Pacific Daylight Time)">10:47</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@smaug:mozilla.org">smaug</span>&gt;</div></td><td class="msg-cell">I saw and commented. I think that stuff isn't needed at all, since the PromiseJobCallback already keeps incumbent global alive and the scheduler thingie can be kept alive on native side, IIRC</td></tr>
  <tr class="msg" id="L8"><td class="ts-cell"><a class="ts" href="#L8" alt="Mon Apr 14 2025 03:48:16 GMT-0700 (Pacific Daylight Time)">10:48</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@smaug:mozilla.org">smaug</span>&gt;</div></td><td class="msg-cell">But didn't verify if there is some need for the existing setup</td></tr>
  <tr class="msg" id="L9"><td class="ts-cell"><a class="ts" href="#L9" alt="Mon Apr 14 2025 03:50:38 GMT-0700 (Pacific Daylight Time)">10:50</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@jonco:mozilla.org">jonco</span>&gt;</div></td><td class="msg-cell">OK that would be great. I don't understand the incumbent global / DOM setup stuff enough to know what's possible here.</td></tr>
  <tr class="msg" id="L10"><td class="ts-cell"><a class="ts" href="#L10" alt="Mon Apr 14 2025 03:52:01 GMT-0700 (Pacific Daylight Time)">10:52</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@smaug:mozilla.org">smaug</span>&gt;</div></td><td class="msg-cell">For the js side of promise handling I think we need some similar-ish setup as what await has, where things gets optimized out</td></tr>
  <tr class="msg" id="L11"><td class="ts-cell"><a class="ts" href="#L11" alt="Mon Apr 14 2025 03:52:14 GMT-0700 (Pacific Daylight Time)">10:52</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@smaug:mozilla.org">smaug</span>&gt;</div></td><td class="msg-cell">But I don't quite understand how that works, so I'm just guessing here</td></tr>
  <tr class="msg" id="L12"><td class="ts-cell"><a class="ts" href="#L12" alt="Mon Apr 14 2025 03:52:31 GMT-0700 (Pacific Daylight Time)">10:52</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@smaug:mozilla.org">smaug</span>&gt;</div></td><td class="msg-cell"><span class="nick-15">arai</span> might know more about that?</td></tr>
  <tr class="msg" id="L13"><td class="ts-cell"><a class="ts" href="#L13" alt="Mon Apr 14 2025 03:53:41 GMT-0700 (Pacific Daylight Time)">10:53</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@smaug:mozilla.org">smaug</span>&gt;</div></td><td class="msg-cell">JS engine does something with canSkipEnqueuingJobs and <em>await</em>. Promises couldn't do quite the same, but perhaps something a bit similar</td></tr>
  <tr class="msg" id="L14"><td class="ts-cell"><a class="ts" href="#L14" alt="Mon Apr 14 2025 03:55:08 GMT-0700 (Pacific Daylight Time)">10:55</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@jonco:mozilla.org">jonco</span>&gt;</div></td><td class="msg-cell">I think we need a way of queueing microtasks that doesn't involve us allocating a JSObject to marshall the arguments every time. If we have a specific proimse job object we should be able to store the data there, although I haven't tried this obviously.</td></tr>
  <tr class="msg" id="L15"><td class="ts-cell"><a class="ts" href="#L15" alt="Mon Apr 14 2025 03:56:14 GMT-0700 (Pacific Daylight Time)">10:56</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@jonco:mozilla.org">jonco</span>&gt;</div></td><td class="msg-cell">I don't know about the await optimisation.</td></tr>
  <tr class="msg" id="L16"><td class="ts-cell"><a class="ts" href="#L16" alt="Mon Apr 14 2025 04:03:02 GMT-0700 (Pacific Daylight Time)">11:03</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@smaug:mozilla.org">smaug</span>&gt;</div></td><td class="msg-cell">On js engine side I think we need a way to keep execution in jit code, if consecutive promisejobs are on the same realm (and no other microtasks  between them). Perhaps one needs to do some check before running a job if the relevant realm should still run JS (is current active window check basically), but that should be relatively fast</td></tr>
  <tr class="msg" id="L17"><td class="ts-cell"><a class="ts" href="#L17" alt="Mon Apr 14 2025 04:04:45 GMT-0700 (Pacific Daylight Time)">11:04</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@jonco:mozilla.org">jonco</span>&gt;</div></td><td class="msg-cell">Yes that sounds like it would help a lot.</td></tr>
  <tr class="msg" id="L18"><td class="ts-cell"><a class="ts" href="#L18" alt="Mon Apr 14 2025 04:04:57 GMT-0700 (Pacific Daylight Time)">11:04</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@smaug:mozilla.org">smaug</span>&gt;</div></td><td class="msg-cell">I <em>think</em> the await optimization does something like that, or something at least vaguely similar.</td></tr>
  <tr class="msg" id="L19"><td class="ts-cell"><a class="ts" href="#L19" alt="Mon Apr 14 2025 04:06:00 GMT-0700 (Pacific Daylight Time)">11:06</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@jonco:mozilla.org">jonco</span>&gt;</div></td><td class="msg-cell">We need a dedicated 'run promise job' API so we can pass that information rather than using standard DOM callback object.</td></tr>
  <tr class="msg" id="L20"><td class="ts-cell"><a class="ts" href="#L20" alt="Mon Apr 14 2025 04:07:01 GMT-0700 (Pacific Daylight Time)">11:07</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@jonco:mozilla.org">jonco</span>&gt;</div></td><td class="msg-cell">Or we could check from JS before return I guess.</td></tr>
  <tr class="msg" id="L21"><td class="ts-cell"><a class="ts" href="#L21" alt="Mon Apr 14 2025 04:08:46 GMT-0700 (Pacific Daylight Time)">11:08</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@smaug:mozilla.org">smaug</span>&gt;</div></td><td class="msg-cell">HTML spec does add its flavor to promises <a href="https://html.spec.whatwg.org/#hostmakejobcallback">https://html.spec.whatwg.org/#hostmakejobcallback</a> and scheduler APIs tweaks that a bit <a href="https://wicg.github.io/scheduling-apis/#sec-patches-html-hostmakejobcallback">https://wicg.github.io/scheduling-apis/#sec-patches-html-hostmakejobcallback</a> (there is a pr for the scheduler API to change the setup a bit more)</td></tr>
  <tr class="msg" id="L22"><td class="ts-cell"><a class="ts" href="#L22" alt="Mon Apr 14 2025 04:15:53 GMT-0700 (Pacific Daylight Time)">11:15</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-4" title="@jonco:mozilla.org">jonco</span>&gt;</div></td><td class="msg-cell">This is where I reach the limit of my understanding. I guess to keep executing promise jobs we need to make sure none of this state has changed (where state is incumbent global, this new sheduler stuff etc). I don't know what causes that to change though. Do we have to check every time? Could we cache the state? Can JS execution even change the incumbent global?</td></tr>
  <tr class="msg" id="L23"><td class="ts-cell"><a class="ts" href="#L23" alt="Mon Apr 14 2025 04:20:34 GMT-0700 (Pacific Daylight Time)">11:20</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@arai:mozilla.org">arai</span>&gt;</div></td><td class="msg-cell">I'll look into the question in 30 min</td></tr>
  <tr class="msg" id="L24"><td class="ts-cell"><a class="ts" href="#L24" alt="Mon Apr 14 2025 04:55:13 GMT-0700 (Pacific Daylight Time)">11:55</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@arai:mozilla.org">arai</span>&gt;</div></td><td class="msg-cell"><p>So, first, when we have <code>await promise</code> expression inside an async function, we need to do the following:</p>
<ol>
<li>create promise reaction for the <code>promise</code></li>
<li>suspend the current async function execution</li>
<li>wait until the <code>promise</code>' gets resolved</li>
<li>enqueue a reaction job to the job queue</li>
<li>wait for the microtask check point if necessary</li>
<li>wait until other jobs executed</li>
<li>resume the async function's execution, with the resolved value of <code>promise</code>'</li>
</ol>
<p>The basic motivation here is that, suspending and resuming the async function is costly, and we want to keep executing the async function without suspending and resuming.<br>But of course, if there's any observable thing happens in step 3, step 5, or step 6 above, we cannot do that.</p>
<p>So, the requirements for it is the folliwng:</p>
<ul>
<li>(a) <code>promise</code> is already resolved at the point of step 1, so that nothing happens in step 3</li>
<li>(b) we're draining the job queue, so that nothing happens in step 5</li>
<li>(c) the job queue is empty, so that nothing happens in step 6</li>
</ul>
<p>The <code>JSContext::canSkipEnqueuingJobs</code> is set to true if the job queue is empty, which is for (c) above, and this is done by Gecko side.<br>(a) is checked by JS engine directly by inspecting the <code>await</code> operand, and (b) is checked by JS engine by checking the call stack.</p>
</td></tr>
  <tr class="msg" id="L25"><td class="ts-cell"><a class="ts" href="#L25" alt="Mon Apr 14 2025 05:07:51 GMT-0700 (Pacific Daylight Time)">12:07</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@arai:mozilla.org">arai</span>&gt;</div></td><td class="msg-cell"><p>Then, in order to expand this into generic promise reactions, the main difference would be that there's no suspend/resume.</p>
<p>For async function's case, there's only one execution path, and the remaining part of the function body depends on the promise resolution.</p>
<p>For generic promise reactions, calling <code>promise.then(value =&gt; ...);</code> has no effect on the current execution stack, and the remaining part of the code gets executed before executing the promise reaction.  So, while the optimizable case would be similar, what to do in the optimizable case would be very different.</p>
</td></tr>
  <tr class="msg" id="L26"><td class="ts-cell"><a class="ts" href="#L26" alt="Mon Apr 14 2025 05:19:13 GMT-0700 (Pacific Daylight Time)">12:19</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@arai:mozilla.org">arai</span>&gt;</div></td><td class="msg-cell"><p>So, for example, if <code>promise.then(onFulfilled);</code> is executed, and if the above (a), (b), and (c) are all true, we could do the following:</p>
<ol>
<li>add a lightweight version of reaction job (a pair of <code>promise</code>'s resolution value and <code>onFulfilled</code> function) to JS-internal job-queue-ish queue</li>
<li>continue the current execution, until the current promise reaction job finishes</li>
<li>once the current job finishes, directly call the reaction jobs, without moving back to the Gecko's job queue</li>
</ol>
<p>This can optimize away the Gecko's job queue handling, and if the onFulfilled comes from the same global, the realm/compartment handlings can also be optimized out.  I'm not sure if this helps in term of JIT tho.</p>
</td></tr>
  <tr class="msg" id="L27"><td class="ts-cell"><a class="ts" href="#L27" alt="Mon Apr 14 2025 05:40:56 GMT-0700 (Pacific Daylight Time)">12:40</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@arai:mozilla.org">arai</span>&gt;</div></td><td class="msg-cell">hm, on the second thought, the (b) may be totally different between them, or we're needing a superset.  for the <code>await</code> case, what we actually want to ensure is that, suspending the async function execution with <code>await</code> will just finish the current job.  so, we check the call stack, and ensure there's no parent frame.  otherwise, there can be other code execution, in the same way as <code>promise.then(...)</code>'s case</td></tr>
  <tr class="msg" id="L28"><td class="ts-cell"><a class="ts" href="#L28" alt="Mon Apr 14 2025 05:42:17 GMT-0700 (Pacific Daylight Time)">12:42</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@arai:mozilla.org">arai</span>&gt;</div></td><td class="msg-cell">so, at least the current logic for (b) doesn't fit for the generic promise's case</td></tr>
  <tr class="msg" id="L29"><td class="ts-cell"><a class="ts" href="#L29" alt="Mon Apr 14 2025 05:51:09 GMT-0700 (Pacific Daylight Time)">12:51</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@arai:mozilla.org">arai</span>&gt;</div></td><td class="msg-cell">is there any example of the structure of the code that appears in wild frequently and needs the optimization? for example, what kind of function/method is called in what kind of context and call stack?</td></tr>
  <tr class="msg" id="L30"><td class="ts-cell"><a class="ts" href="#L30" alt="Mon Apr 14 2025 06:44:25 GMT-0700 (Pacific Daylight Time)">13:44</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-15" title="@arai:mozilla.org">arai</span>&gt;</div></td><td class="msg-cell">(moved to DM for the example case)</td></tr>
  <tr class="msg" id="L31"><td class="ts-cell"><a class="ts" href="#L31" alt="Mon Apr 14 2025 08:50:12 GMT-0700 (Pacific Daylight Time)">15:50</a></td><td class="nick-cell"><div class="m-ov">&lt;<span class="nick nick-2" title="@mgaudet:mozilla.org">mgaudet</span>&gt;</div></td><td class="msg-cell"><p>So I'd make two comments here:</p>
<ol>
<li>
<p>I think one of the challenges we face right now is that our implementations of jobs and queues are very opaque to SM because they're considered properties of the embedding. The problem is that practically speaking, while we do need to handle non-JS tasks, it seems that we <a href="https://bugzilla.mozilla.org/show_bug.cgi?id=1959766">frequently have an order of magnitude more JS tasks than non-JS</a></p>
</li>
<li>
<p>I -think- there's a profitable story here that creates a hybrid queue (where specification requirements are largely kept with gecko, but the queue itself is moved within SM). A rough plan is <a href="https://gist.github.com/mgaudet/8e2350aa16fd130fdaf4c8bb0f1a6da6">here</a> written up friday, but given the current conversation thought may as well bring it up here.</p>
</li>
</ol>
<p>I think this direction, while not super principled architecturally, might be worht at least experimenting with. The big advantage being that if we go down this road we get potentially getting to the point where we can optimize job enqueue and draining profitably.</p>
</td></tr>

</tbody></table></div></div></div>
</body></html>